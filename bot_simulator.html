<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>مدیریت تیکت تل (Mini App)</title>
    <!-- بارگذاری Tailwind CSS و Lucide Icons -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <!-- بارگذاری فونت‌ها -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;600;700;800&display=swap" rel="stylesheet">
    
    <style>
        /* تنظیم فونت و تم اصلی */
        body {
            /* استفاده از فونت وزیرمتن برای فارسی و Inter برای انگلیسی */
            font-family: 'Vazirmatn', 'Inter', Tahoma, sans-serif;
            background-color: #f3f4f6; /* پس‌زمینه خاکستری بسیار روشن */
        }
        
        /* سبک برای textarea با قابلیت بزرگ شدن خودکار */
        .auto-resize-textarea {
            overflow: hidden; 
            resize: none; 
            min-height: 120px;
            height: auto;
        }

        /* انیمیشن برای نمودار دایره‌ای */
        @keyframes donut-chart-fill {
            from { stroke-dashoffset: 100; }
            to { stroke-dashoffset: var(--stroke-offset, 100); }
        }
        .donut-chart-fg {
            animation: donut-chart-fill 1s ease-out forwards;
        }
    </style>
</head>
<body class="bg-gray-100">

    <!-- شبیه‌سازی صفحه اپلیکیشن موبایل -->
    <!-- 
        تغییرات ظاهری:
        - تمام صفحه در موبایل (h-screen)
        - کارت شبیه‌ساز موبایل در دسکتاپ (md:h-[800px], md:rounded-2xl, md:shadow-xl)
        - استفاده از flex-col برای تقسیم‌بندی هدر، محتوا و فوتر
    -->
    <div id="app-screen" class="w-full max-w-md mx-auto bg-white flex flex-col h-screen md:h-[800px] md:mt-8 md:mb-8 md:rounded-2xl md:shadow-xl overflow-hidden">
        
        <!-- 
            هدر ثابت:
            - حذف گرادیانت و استفاده از پس‌زمینه سفید
            - اضافه کردن خط پایین (border-b) برای جداسازی
            - تغییر رنگ متن به تیره
        -->
        <header class="bg-white border-b border-gray-200 p-4 flex items-center shadow-sm flex-shrink-0">
            <!-- آیکون بازگشت -->
            <button id="back-button" class="text-gray-600 p-2 hover:bg-gray-100 rounded-full transition duration-150 hidden">
                <i data-lucide="chevron-right" class="h-6 w-6"></i>
            </button>
            <h1 id="header-title" class="text-xl font-extrabold text-gray-900 mr-4 flex-grow truncate">پنل مدیریت ربات</h1>
        </header>

        <!-- 
            کانتینر اصلی محتوا:
            - flex-grow باعث می‌شود این بخش تمام فضای باقی‌مانده را بگیرد
            - overflow-y-auto اسکرول داخلی را فقط برای این بخش فعال می‌کند
        -->
        <div id="content" class="flex-grow overflow-y-auto p-5 space-y-5 bg-gray-50/50">
            <div id="loading-spinner" class="text-center p-8">
                <i data-lucide="loader-circle" class="animate-spin h-10 w-10 text-indigo-600 inline"></i>
                <p class="mt-4 text-gray-600 font-semibold">در حال بارگذاری داده‌های اولیه...</p>
            </div>
        </div>

        <!-- 
            فوتر:
            - این بخش برای دکمه‌های عملیاتی (مثل داشبورد و صفحه ویرایش) استفاده می‌شود
            - به پایین صفحه می‌چسبد
        -->
        <footer id="app-footer" class="p-4 bg-white border-t border-gray-100 shadow-inner flex-shrink-0 hidden">
            <!-- محتوای فوتر به صورت داینامیک اضافه می‌شود -->
        </footer>

        <!-- پیام نمایش داده شده در پایین صفحه -->
        <div id="message-box" class="fixed bottom-0 left-0 right-0 p-4 text-white text-center rounded-t-xl shadow-2xl z-20 hidden">
            عملیات با موفقیت انجام شد!
        </div>
    </div>

    <script>
        // --- تنظیمات مهم (WORKER & STORE) ---

        // 1. استخراج STORE_HANDLE از پارامتر URL
        const urlParams = new URLSearchParams(window.location.search);
        const STORE_HANDLE = urlParams.get('storeHandle'); 
        
        // --- MOCK DATA FOR TESTING IN CANVAS ---
        const MOCK_STORE_HANDLE = 'test-store-mock-dfdfdfd'; 
        
        const mockAppTexts = {
            greetingTitle: "سلام مدیر عزیز! 👋 (آزمایشی)",
            quickTipMessage: "💡 نکته: این متون برای تست در حالت آزمایشی بارگذاری شده‌اند.",
            faqButtonEnabled: "true", 
            faqButtonText: "مشاهده سوالات متداول",
            faqUrl: "https://mock.faq.com/",
            navTickets: "تیکت‌ها",
            navNewTicket: "تیکت جدید",
            infoModalTitle: "راهنمای ارسال تیکت",
            infoModalTip: "لطفا ابتدا صفحه سوالات متداول را بررسی کنید.",
            closedTicketBanner: "این گفتگو توسط پشتیبانی بسته شده است.",
            submitNewTicketBtn: "ارسال",
            modalCloseBtn: "متوجه شدم",
            userReplyNotification: "✅ *پشتیبانی فنی* به تیکت شما با موضوع *مشکل اتصال* پاسخ داد.\\n\\nبرای مشاهده پاسخ کلیک کنید.",
            ticketClosedNotification: "🎫 تیکت شما با موضوع *پرداخت ناموفق* بسته شد.\\n\\nلطفا امتیاز دهید.",
        };
        
        const mockAppStats = {
            totalCount: '145',
            totalActive: '4',
            openCount: '3',
            pendingCount: '1',
            avgRating: '4.92',
            ratingPercentage: '88.5',
            ratedTicketsCount: 120,
            avgFirstResponseTime: '3 ساعت و 15 دقیقه',
            avgTimeToResolution: '1 روز و 5 ساعت',
        };

        // 2. آدرس پایه Worker API
        const WORKER_API_BASE_URL = 'https://ticketing.amiruserbot7.workers.dev'; 

        // تابع برای ساخت عنوان داشبورد
        const getDashboardTitle = (handle) => `داشبورد مدیریت (${handle || 'ناشناس'})`;


        // --- پایان تنظیمات ---

        const content = document.getElementById('content');
        const appFooter = document.getElementById('app-footer');
        const backButton = document.getElementById('back-button');
        const headerTitle = document.getElementById('header-title');
        const messageBox = document.getElementById('message-box');

        // وضعیت‌های اصلی: Dashboard, MainMenu, SubMenu_MINIAPPUI, SubMenu_USERNOTIFICATIONS, EditScreen
        let currentState = 'Loading';
        const history = [];
        let appTexts = {}; // ذخیره متون دریافتی از Worker
        let appStats = {}; // ذخیره آمار دریافتی از Worker
        let currentEditKey = null; // کلید متنی که در حال ویرایش است
        let successMessage = null; // برای نمایش پیام موفقیت در ناوبری

        // ساختار ثابت متون برای استفاده در منوها (باید با Worker همگام باشد)
        const CUSTOM_TEXT_KEYS = {
            MINI_APP_UI: {
                greetingTitle: { name: "عنوان خوش‌آمدگویی", icon: "user-check", desc: `متن اصلی کارت راهنما (مثلاً: سلام مشتری عزیز!)` },
                quickTipMessage: { name: "پیام راهنمای سریع", icon: "lightbulb", desc: `متن کوچک زیر عنوان در کارت راهنما (مثلاً: لطفا مشکل را با جزئیات بنویسید)` },
                faqButtonEnabled: { name: "وضعیت دکمه راهنما", icon: "toggle-right", desc: `دکمه سوالات متداول را در مینی‌اپ فعال یا غیرفعال کنید.`, isBoolean: true },
                faqButtonText: { name: "متن دکمه راهنما", icon: "help-circle", desc: `متنی که روی دکمه مشاهده سوالات متداول نمایش داده می‌شود.` },
                faqUrl: { name: "لینک دکمه راهنما", icon: "link", desc: `آدرس URL کامل (باید با https:// شروع شود).`, isUrl: true }, 
                navTickets: { name: "منوی: تیکت‌ها", icon: "ticket", desc: `متن آیکون تیکت‌ها در نوار پایین مینی‌اپ.` },
                navNewTicket: { name: "منوی: تیکت جدید", icon: "file-plus", desc: `متن آیکون ایجاد تیکت جدید در نوار پایین مینی‌اپ.` },
                infoModalTitle: { name: "عنوان راهنمای تیکت", icon: "info", desc: `عنوان پنجره‌ای که قبل از ثبت تیکت جدید نمایش داده می‌شود.` },
                infoModalTip: { name: "پیام راهنمای مودال", icon: "message-square-text", desc: `متن اصلی داخل پنجره راهنما قبل از ثبت تیکت.` },
                closedTicketBanner: { name: "بنر تیکت بسته شده", icon: "lock", desc: `متنی که در پایین یک تیکت بسته شده نمایش داده می‌شود.` },
                submitNewTicketBtn: { name: "متن دکمه ارسال", icon: "send", desc: `متنی که روی دکمه 'ارسال' تیکت جدید نمایش داده می‌شود.` },
                modalCloseBtn: { name: "متن دکمه متوجه شدم", icon: "x-circle", desc: `متن دکمه بستن پنجره‌های مودال.` },
            },
            USER_NOTIFICATIONS: {
                userReplyNotification: { name: "اعلان پاسخ ادمین", icon: "bell-plus", desc: `متنی که پس از پاسخ ادمین، برای کاربر ارسال می‌شود. این متن از متغیرهای پویا پشتیبانی می‌کند.` },
                ticketClosedNotification: { name: "اعلان بسته شدن تیکت", icon: "bell-off", desc: `متنی که پس از بستن تیکت، برای کاربر ارسال می‌شود. این متن از متغیرهای پویا پشتیبانی می‌کند.` },
            }
        };


        // --- توابع کمکی ---
        
        function autoResize(el) {
            el.style.height = 'auto';
            el.style.height = (el.scrollHeight) + 'px';
        }

        function getFullKeyData(key) {
            for (const menuType in CUSTOM_TEXT_KEYS) {
                if (CUSTOM_TEXT_KEYS[menuType][key]) {
                    return { type: menuType, key, ...CUSTOM_TEXT_KEYS[menuType][key] };
                }
            }
            return null;
        }

        function showMessage(text, type = 'success', duration = 4000) {
            messageBox.textContent = text;
            messageBox.className = `fixed bottom-0 left-0 right-0 p-4 text-white text-center rounded-t-2xl shadow-2xl z-20 ${type === 'success' ? 'bg-green-600' : 'bg-red-600'}`;
            messageBox.classList.remove('hidden');
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, duration);
        }

        function navigateTo(newState, title = null, pushHistory = true) {
            if (pushHistory && currentState !== 'Loading') {
                history.push(currentState);
            }
            currentState = newState;
            
            const currentHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            const dashboardTitle = getDashboardTitle(currentHandle);
            
            headerTitle.textContent = title || dashboardTitle;
            render();
        }

        function handleBack() {
            if (currentState.startsWith('EditScreen_')) {
                currentEditKey = null;
            }

            if (history.length > 0) {
                const previousState = history.pop();
                
                const currentHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
                const dashboardTitle = getDashboardTitle(currentHandle);
                
                let title = dashboardTitle;
                if (previousState === 'MainMenu') {
                    title = 'مدیریت متون';
                } else if (previousState.startsWith('SubMenu_')) {
                    const menuType = previousState.replace('SubMenu_', '');
                    title = menuType === 'MINI_APP_UI' ? 'متن‌های مینی‌اپ' : 'متن‌های اعلان ربات';
                }
                
                currentState = previousState;
                headerTitle.textContent = title;
                render(false);
            } else {
                navigateTo('Dashboard', getDashboardTitle(STORE_HANDLE || MOCK_STORE_HANDLE), false); 
            }
        }

        // --- Data Fetching (از Worker API) ---

        async function fetchStats() {
            const currentStoreHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            if (currentStoreHandle === MOCK_STORE_HANDLE) return mockAppStats; 

            const url = `${WORKER_API_BASE_URL}/api/${currentStoreHandle}/stats`;
            const response = await fetch(url);
            if (!response.ok) throw new Error('Failed to fetch stats from Worker.');
            const result = await response.json();
            if (!result.success) throw new Error(result.error || 'Worker stats returned error.');
            return result.data;
        }

        async function fetchAppTexts() {
            const currentStoreHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            if (currentStoreHandle === MOCK_STORE_HANDLE) return mockAppTexts; 

            const url = `${WORKER_API_BASE_URL}/api/${currentStoreHandle}/texts`;
            const response = await fetch(url);
            if (!response.ok) throw new Error('Worker failed to fetch texts.');
            const result = await response.json();
            if (!result.success) throw new Error(result.error || 'Worker texts returned error.');
            return result.data;
        }

        async function fetchInitialData() {
            try {
                if (!STORE_HANDLE) {
                    throw new Error("Missing STORE_HANDLE, loading mock data.");
                }

                const [textsData, statsData] = await Promise.all([
                    fetchAppTexts(),
                    fetchStats()
                ]);

                appTexts = textsData;
                appStats = statsData;

            } catch (error) {
                console.warn(`Error in fetchInitialData: ${error.message}. Loading mock data...`);
                appTexts = mockAppTexts;
                appStats = mockAppStats;
                if(error.message !== "Missing STORE_HANDLE, loading mock data."){
                    showMessage(`❌ خطا در اتصال به API: ${error.message.substring(0, 50)}... بارگذاری داده آزمایشی.`, 'error');
                }
            }
            currentState = 'Dashboard';
            render();
        }

        // --- Data Persistence (از طریق Worker API) ---
        async function handleSave() {
            const saveButton = document.getElementById('save-button');
            const editElement = document.getElementById('edit-area');
            const newText = editElement.value; 

            if (!currentEditKey) return;
            const keyData = getFullKeyData(currentEditKey);

            if (keyData.isUrl) {
                if (!newText.startsWith('https://')) {
                    showMessage('❌ لینک باید با https:// شروع شود.', 'error', 5000);
                    return;
                }
            }

            saveButton.disabled = true;
            saveButton.innerHTML = '<i data-lucide="loader-circle" class="animate-spin h-5 w-5 inline mr-2"></i> در حال ذخیره...';
            lucide.createIcons(); 

            const currentStoreHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            
            if (currentStoreHandle === MOCK_STORE_HANDLE) {
                appTexts[currentEditKey] = newText;
                successMessage = `✅ تنظیم "${keyData.name}" با موفقیت در حالت آزمایشی ذخیره شد!`;
                
                navigateTo(`SubMenu_${keyData.type}`, 'مدیریت متون');
                return;
            }

            const url = `${WORKER_API_BASE_URL}/api/${currentStoreHandle}/texts`;
            const payload = { [currentEditKey]: newText };

            try {
                const response = await fetch(url, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();

                if (response.ok && result.success) {
                    appTexts[currentEditKey] = newText; 
                    successMessage = `✅ تنظیم "${keyData.name}" با موفقیت ذخیره و اعمال شد!`;
                    
                    navigateTo(`SubMenu_${keyData.type}`, 'مدیریت متون');
                } else {
                    throw new Error(result.error || 'خطا در Worker API هنگام ذخیره.');
                }
            } catch (error) {
                console.error("Error saving text via Worker:", error);
                showMessage(`❌ خطا در ذخیره تنظیم: ${error.message}`, 'error');
            } finally {
                // دکمه ذخیره در فوتر است و در ناوبری بعدی حذف می‌شود،
                // اما اگر خطا رخ دهد، باید آن را به حالت اول برگردانیم.
                if (document.getElementById('save-button')) {
                    saveButton.disabled = false;
                    saveButton.innerHTML = '<i data-lucide="save" class="h-5 w-5 inline ml-1"></i> ذخیره و اعمال تغییرات';
                    lucide.createIcons();
                }
            }
        }


        // =================================================================
        // RENDER FUNCTIONS (UI)
        // =================================================================

        /**
         * رندر نمودار دایره‌ای (Donut Chart)
         * شبیه به چیزی که در ویدیو دیدیم
         */
        function renderDonutChart(percentage) {
            const percent = Math.max(0, Math.min(100, parseFloat(percentage) || 0));
            const radius = 52;
            const circumference = 2 * Math.PI * radius; // 100
            const offset = circumference - (percent / 100) * circumference; // 0

            let strokeColor = "text-green-500"; // سبز برای امتیاز بالا
            if (percent < 90) strokeColor = "text-yellow-500"; // زرد برای متوسط
            if (percent < 75) strokeColor = "text-red-500"; // قرمز برای پایین

            return `
                <div class="relative flex items-center justify-center w-40 h-40 mx-auto">
                    <svg class="w-full h-full" viewBox="0 0 120 120">
                        <!-- پس‌زمینه (ترک) -->
                        <circle
                            class="text-gray-200"
                            stroke-width="12"
                            stroke="currentColor"
                            fill="transparent"
                            r="${radius}"
                            cx="60"
                            cy="60"
                        />
                        <!-- پیشرفت (fill) -->
                        <circle
                            class="donut-chart-fg ${strokeColor}"
                            stroke-width="12"
                            stroke-linecap="round"
                            stroke="currentColor"
                            fill="transparent"
                            r="${radius}"
                            cx="60"
                            cy="60"
                            transform="rotate(-90 60 60)"
                            style="stroke-dasharray: ${circumference}; --stroke-offset: ${offset}; stroke-dashoffset: ${circumference};"
                        />
                    </svg>
                    <!-- متن درصد در وسط -->
                    <div class="absolute flex flex-col items-center justify-center">
                        <span class="text-3xl font-extrabold text-gray-800">${percent.toFixed(0)}%</span>
                        <span class="text-xs text-gray-500">رضایت</span>
                    </div>
                </div>
            `;
        }

        function renderDashboard() {
            backButton.classList.add('hidden');
            appFooter.classList.remove('hidden'); // نمایش فوتر
            
            const currentHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            headerTitle.textContent = getDashboardTitle(currentHandle);
            const stats = appStats;

            if (successMessage) {
                showMessage(successMessage);
                successMessage = null;
            }
            
            const ratingPercent = parseFloat(stats.ratingPercentage || '0');

            // تعریف کارت‌های متریک
            // تغییرات ظاهری: استفاده از bg-white، سایه نرم‌تر، و پدینگ بیشتر
            const metricCards = [
                { title: "کل تیکت‌ها", value: stats.totalCount || '0', icon: "ticket", color: "text-indigo-600", desc: "تعداد کل تیکت‌های ثبت شده." },
                { title: "تیکت‌های فعال", value: stats.totalActive || '0', icon: "inbox", color: "text-red-600", desc: "باز و در انتظار پاسخ." },
                { title: "میانگین پاسخ", value: stats.avgFirstResponseTime || 'N/A', icon: "clock-3", color: "text-green-600", desc: "اولین پاسخگویی." },
                { title: "زمان حل نهایی", value: stats.avgTimeToResolution || 'N/A', icon: "zap", color: "text-purple-600", desc: "زمان تا بستن تیکت." },
            ];

            content.innerHTML = `
                <div class="space-y-5 pb-20"> <!-- اضافه کردن padding-bottom برای جلوگیری از همپوشانی با فوتر -->
                    
                    <h2 class="text-2xl font-extrabold text-gray-800 border-b pb-3 mb-4">گزارش عملکرد</h2>
                    
                    <!-- گرید کارت‌های متریک -->
                    <div class="grid grid-cols-2 gap-4">
                        ${metricCards.map(card => `
                            <!-- 
                                تغییر استایل کارت:
                                - bg-white, rounded-2xl, shadow-sm, border
                                - پدینگ بیشتر (p-5)
                                - طراحی شبیه به ویدیو
                            -->
                            <div class="bg-white p-5 rounded-2xl shadow-sm border border-gray-100 transition-all hover:shadow-md hover:border-gray-200">
                                <div class="flex items-center justify-between mb-3">
                                    <h3 class="text-sm font-semibold text-gray-500">${card.title}</h3>
                                    <i data-lucide="${card.icon}" class="${card.color} h-6 w-6"></i>
                                </div>
                                <p class="text-3xl font-extrabold text-gray-900">${card.value}</p>
                                <p class="text-xs text-gray-400 mt-1 truncate">${card.desc}</p>
                            </div>
                        `).join('')}
                    </div>

                    <!-- 
                        کارت نمودار رضایت کاربران:
                        - این کارت شبیه به نمودار دایره‌ای در ویدیو است
                    -->
                    <div class="bg-white p-5 rounded-2xl shadow-sm border border-gray-100">
                        <h3 class="text-lg font-bold text-gray-800 mb-4 text-center">شاخص رضایت کاربران</h3>
                        ${renderDonutChart(ratingPercent)}
                        <div class="flex justify-between text-sm mt-4 pt-4 border-t border-gray-100">
                            <span class="text-gray-600">میانگین امتیاز:</span>
                            <span class="font-bold text-yellow-600 flex items-center">
                                <i data-lucide="star" class="h-4 w-4 ml-1 fill-current"></i>
                                ${stats.avgRating || 'N/A'} / 5.00
                            </span>
                        </div>
                        <div class="flex justify-between text-sm mt-2">
                            <span class="text-gray-600">تعداد امتیازات:</span>
                            <span class="font-bold text-gray-800">${stats.ratedTicketsCount || 0}</span>
                        </div>
                    </div>
                </div>
            `;
            
            // دکمه مدیریت در فوتر چسبان
            appFooter.innerHTML = `
                <button onclick="navigateTo('MainMenu', 'مدیریت متون')" class="w-full bg-gradient-to-r from-indigo-600 to-purple-600 text-white py-3.5 rounded-2xl shadow-lg shadow-indigo-400/50 hover:from-indigo-700 hover:to-purple-700 transition duration-300 font-bold flex items-center justify-center text-base">
                    <i data-lucide="settings" class="h-5 w-5 ml-2"></i> مدیریت متون و تنظیمات
                </button>
            `;

            lucide.createIcons();
        }

        function renderMainMenu() {
            backButton.classList.remove('hidden');
            appFooter.classList.add('hidden'); // در این صفحه فوتر نداریم
            headerTitle.textContent = 'مدیریت متون';
            
            if (successMessage) {
                showMessage(successMessage);
                successMessage = null;
            }

            content.innerHTML = `
                <h2 class="text-2xl font-extrabold text-gray-800 mb-2">شخصی‌سازی محتوا</h2>
                <p class="text-sm text-gray-500 mb-6">متون کلیدی مینی اپ و اعلان‌های ارسال شده به کاربران را ویرایش کنید.</p>
                
                <!-- 
                    تغییر استایل منو:
                    - هر آیتم یک کارت جداگانه است (شبیه به ویدیو)
                    - حذف `divide-y` و استفاده از `space-y-3`
                -->
                <div class="space-y-3 pb-16">
                    <div class="bg-white p-5 rounded-2xl shadow-sm border border-gray-100 flex items-center justify-between transition-all duration-150 hover:shadow-md hover:border-indigo-300 hover:bg-indigo-50/50 cursor-pointer" onclick="navigateTo('SubMenu_MINI_APP_UI', 'متن‌های مینی‌اپ')">
                        <span class="flex items-center font-medium text-gray-800">
                            <i data-lucide="smartphone" class="h-5 w-5 ml-3 text-indigo-600"></i>
                            متن‌های مینی‌اپ (رابط کاربری)
                        </span>
                        <i data-lucide="chevron-left" class="h-5 w-5 text-gray-400"></i>
                    </div>
                    <div class="bg-white p-5 rounded-2xl shadow-sm border border-gray-100 flex items-center justify-between transition-all duration-150 hover:shadow-md hover:border-orange-300 hover:bg-orange-50/50 cursor-pointer" onclick="navigateTo('SubMenu_USER_NOTIFICATIONS', 'متن‌های اعلان ربات')">
                        <span class="flex items-center font-medium text-gray-800">
                            <i data-lucide="bell" class="h-5 w-5 ml-3 text-orange-600"></i>
                            متن‌های اعلان کاربر (ربات)
                        </span>
                        <i data-lucide="chevron-left" class="h-5 w-5 text-gray-400"></i>
                    </div>
                    <div class="bg-white p-5 rounded-2xl shadow-sm border border-gray-100 flex items-center justify-between transition-all duration-150 hover:shadow-md hover:border-gray-300 hover:bg-gray-50/50 cursor-pointer" onclick="navigateTo('Dashboard', getDashboardTitle(STORE_HANDLE || MOCK_STORE_HANDLE))">
                        <span class="flex items-center font-medium text-gray-600">
                            <i data-lucide="layout-dashboard" class="h-5 w-5 ml-3 text-gray-400"></i>
                            بازگشت به داشبورد
                        </span>
                    </div>
                </div>
            `;
            lucide.createIcons();
        }

        function renderSubMenu_Texts(state) {
            backButton.classList.remove('hidden');
            appFooter.classList.add('hidden'); // در این صفحه فوتر نداریم
            const menuType = state.replace('SubMenu_', ''); 
            const keys = CUSTOM_TEXT_KEYS[menuType];
            const menuTitle = menuType === 'MINI_APP_UI' ? "متن‌های رابط کاربری" : "متن‌های اعلان ربات";
            
            headerTitle.textContent = menuTitle;

            if (successMessage) {
                showMessage(successMessage);
                successMessage = null;
            }

            content.innerHTML = `
                <h2 class="text-2xl font-extrabold text-gray-800 mb-2">${menuTitle}</h2>
                <p class="text-sm text-gray-500 mb-6">متن مورد نظر برای ویرایش را انتخاب کنید:</p>
                
                <!-- استفاده از همان استایل کارت‌ها برای منو -->
                <div class="space-y-3 pb-16">
                    ${Object.entries(keys).map(([key, data]) => {
                        const menuIcon = data.icon || 'file-text';
                        const iconColor = menuType === 'MINI_APP_UI' ? 'text-indigo-500' : 'text-orange-500';
                        
                        let additionalInfo = '';
                        if (data.isBoolean) {
                            const currentValue = (appTexts[key] === "true" || typeof appTexts[key] === 'undefined');
                            additionalInfo = currentValue
                                ? `<span class="text-xs font-semibold bg-green-100 text-green-700 px-2 py-0.5 rounded-full">فعال</span>`
                                : `<span class="text-xs font-semibold bg-gray-100 text-gray-600 px-2 py-0.5 rounded-full">غیرفعال</span>`;
                        }

                        return `
                            <div class="bg-white p-5 rounded-2xl shadow-sm border border-gray-100 flex items-center justify-between transition-all duration-150 hover:shadow-md hover:border-indigo-300 hover:bg-indigo-50/50 cursor-pointer" onclick="navigateTo('EditScreen_${key}', 'ویرایش: ${data.name}')">
                                <span class="flex items-center text-gray-800">
                                    <i data-lucide="${menuIcon}" class="h-5 w-5 ml-3 ${iconColor}"></i>
                                    ${data.name}
                                </span>
                                <div class="flex items-center">
                                    ${additionalInfo}
                                    <i data-lucide="chevron-left" class="h-5 w-5 text-gray-400 mr-2"></i>
                                </div>
                            </div>
                        `;
                    }).join('')}
                    <div class="bg-white p-5 rounded-2xl shadow-sm border border-gray-100 flex items-center justify-between transition-all duration-150 hover:shadow-md hover:border-gray-300 hover:bg-gray-50/50 cursor-pointer" onclick="navigateTo('MainMenu', 'مدیریت متون')">
                        <span class="flex items-center font-medium text-indigo-600">
                            <i data-lucide="undo-2" class="h-5 w-5 ml-3"></i>
                            بازگشت به منوی اصلی
                        </span>
                    </div>
                </div>
            `;
            lucide.createIcons();
        }

        function renderEditScreen(state) {
            backButton.classList.remove('hidden');
            appFooter.classList.remove('hidden'); // نمایش فوتر برای دکمه‌ها
            
            currentEditKey = state.replace('EditScreen_', '');
            const keyData = getFullKeyData(currentEditKey);

            if (!keyData) {
                content.innerHTML = `<p class="text-red-600 p-4 font-bold">خطا: کلید متنی نامعتبر است.</p>`;
                appFooter.classList.add('hidden'); // خطاست، فوتر را مخفی کن
                return;
            }

            headerTitle.textContent = `ویرایش: ${keyData.name}`;

            const isNotification = keyData.type === 'USER_NOTIFICATIONS';
            const isUrlField = keyData.isUrl;
            const isBooleanField = keyData.isBoolean; 

            const currentText = (appTexts[currentEditKey] || keyData.defaultText || "متن پیش‌فرض موجود نیست.").replace(/\\n/g, '\n');
            
            let markdownGuideHTML = '';
            let inputElement;

            if (isNotification) {
                markdownGuideHTML = `
                    <div class="bg-blue-50 border-r-4 border-blue-400 p-4 mb-4 rounded-xl text-sm text-gray-700 shadow-inner">
                        <p class="font-bold text-blue-700 flex items-center mb-2"><i data-lucide="code" class="h-5 w-5 ml-2"></i> راهنمای حرفه‌ای Markdown و متغیرها</p>
                        <div class="bg-white border rounded-lg overflow-hidden mt-3">
                            <table class="w-full text-right text-xs">
                                <thead class="bg-gray-100 font-semibold text-gray-600">
                                    <tr>
                                        <th class="p-2 border-b">سینتکس</th>
                                        <th class="p-2 border-b">توضیح</th>
                                        <th class="p-2 border-b">نمونه خروجی</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr class="hover:bg-gray-50"><td class="p-2 border-b font-mono">**متن**</td><td class="p-2 border-b">متن بولد</td><td class="p-2 border-b font-bold">متن ضخیم</td></tr>
                                    <tr class="hover:bg-gray-50"><td class="p-2 border-b font-mono">*متن*</td><td class="p-2 border-b">متن کج</td><td class="p-2 border-b italic">متن کج</td></tr>
                                    <tr class="hover:bg-gray-50"><td class="p-2 border-b font-mono">\`کد\`</td><td class="p-2 border-b">نوشتن کد یا ID</td><td class="p-2 border-b font-mono text-sm bg-gray-100 rounded">کد</td></tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="font-bold text-blue-700 mt-4 mb-1 flex items-center"><i data-lucide="variable" class="h-5 w-5 ml-2"></i> متغیرهای پویا</p>
                        <p class="mb-2">از متغیرهای زیر استفاده کنید:</p>
                        <ul class="list-disc pr-5 space-y-1 font-mono text-xs">
                            <li><code>{Subject}</code>: موضوع تیکت</li>
                            <li><code>{Department}</code>: نام دپارتمان</li>
                        </ul>
                    </div>
                `;
            } else {
                 const description = keyData.desc || 'توضیحات خاصی برای این متن موجود نیست. لطفاً آن را ساده و مختصر نگه دارید.';
                 markdownGuideHTML = `
                     <div class="bg-yellow-50 border-r-4 border-yellow-400 p-3 mb-4 rounded-xl text-sm text-gray-700 flex items-start shadow-inner">
                         <i data-lucide="alert-triangle" class="h-5 w-5 ml-2 text-yellow-700 flex-shrink-0 mt-0.5"></i>
                         <div>
                             <span class="font-bold text-yellow-700 ml-1">راهنمای متن:</span>
                             <span>${description}</span>
                         </div>
                     </div>
                   `;
            }

            // استایل ورودی‌ها به‌روزرسانی شد:
            // - text-lg برای خوانایی بهتر
            // - border-gray-200
            // - shadow-sm
            const inputBaseClasses = "w-full p-4 border border-gray-200 rounded-xl shadow-sm focus:border-indigo-500 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 transition duration-150 text-gray-800 text-lg bg-white";

            if (isUrlField) {
                inputElement = `
                    <input id="edit-area" type="url" value="${currentText.replace(/\n/g, '')}" class="${inputBaseClasses}" placeholder="مثلاً: https://yourdomain.com/faq">
                `;
            } else if (isBooleanField) {
                const currentValue = (appTexts[currentEditKey] || "true"); 
                inputElement = `
                    <select id="edit-area" class="${inputBaseClasses}">
                        <option value="true" ${currentValue === "true" ? 'selected' : ''}>فعال (نمایش داده شود)</option>
                        <option value="false" ${currentValue === "false" ? 'selected' : ''}>غیرفعال (مخفی شود)</option>
                    </select>
                `;
            } else {
                inputElement = `
                    <textarea id="edit-area" rows="4" class="auto-resize-textarea ${inputBaseClasses}" placeholder="متن جدید خود را اینجا وارد کنید...">${currentText}</textarea>
                `;
            }

            content.innerHTML = `
                <!-- 
                    محتوای صفحه ویرایش:
                    - pb-24 برای ایجاد فاصله از فوتر چسبان
                -->
                <div class="pb-24">
                    <h2 class="text-2xl font-extrabold text-gray-800 mb-2">ویرایش: ${keyData.name}</h2>
                    ${markdownGuideHTML}
                    ${inputElement}
                </div>
            `;
            
            // دکمه‌های عملیات در فوتر چسبان
            // تغییر استایل دکمه لغو
            appFooter.innerHTML = `
                <div class="flex justify-end space-x-3" dir="ltr">
                    <button onclick="handleBack()" class="px-5 py-3 bg-gray-100 text-gray-700 rounded-xl hover:bg-gray-200 transition duration-150 font-semibold shadow-sm">
                        <i data-lucide="x-circle" class="h-5 w-5 inline ml-1"></i> لغو
                    </button>
                    <button id="save-button" onclick="handleSave()" class="px-5 py-3 bg-gradient-to-r from-indigo-600 to-purple-600 text-white rounded-xl hover:from-indigo-700 hover:to-purple-700 transition duration-150 font-semibold shadow-lg shadow-indigo-400/50">
                        <i data-lucide="save" class="h-5 w-5 inline ml-1"></i> ذخیره تغییرات
                    </button>
                </div>
            `;
            
            lucide.createIcons();
            
            const editArea = document.getElementById('edit-area');
            if (editArea && !isUrlField && !isBooleanField) { 
                autoResize(editArea); 
                editArea.addEventListener('input', () => autoResize(editArea));
            }
        }


        // --- تابع اصلی رندر ---

        function render() {
            if (currentState === 'Loading') {
                content.innerHTML = document.getElementById('loading-spinner').outerHTML;
                appFooter.classList.add('hidden'); // مخفی کردن فوتر هنگام لود
                lucide.createIcons(); 
                return;
            }

            // افکت محو شدن برای جابجایی بین صفحات
            content.classList.add('transition-opacity', 'duration-150', 'opacity-0');
            
            setTimeout(() => {
                
                if (currentState === 'Dashboard') {
                    renderDashboard();
                } else if (currentState === 'MainMenu') {
                    renderMainMenu();
                } else if (currentState.startsWith('SubMenu_')) {
                    renderSubMenu_Texts(currentState);
                } else if (currentState.startsWith('EditScreen_')) {
                    renderEditScreen(currentState);
                } else {
                    renderDashboard();
                }
                
                backButton.classList[history.length > 0 ? 'remove' : 'add']('hidden');
                
                content.classList.remove('opacity-0');
            }, 100); // زمان کوتاه برای افکت
        }

        // رویدادهای اصلی
        backButton.addEventListener('click', handleBack);

        // شروع اپلیکیشن
        fetchInitialData();
    </script>
    <script>
        // آیکون‌ها را در بارگذاری اولیه ایجاد می‌کند
        window.onload = function() {
            lucide.createIcons();
        }
    </script>
</body>
</html>
