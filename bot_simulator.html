<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>مدیریت تیکت تل (Mini App)</title>
    <!-- بارگذاری Tailwind CSS و Lucide Icons -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <!-- [جدید] کتابخانه نمودار Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <!-- فونت‌های جدید: Vazirmatn برای فارسی و Inter برای انگلیسی -->
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    
    <style>
        /* ... (استایل‌های قبلی بدون تغییر) ... */
        body {
            font-family: 'Vazirmatn', 'Inter', Tahoma, sans-serif;
            background-color: #f7f8fa; /* پس‌زمینه خاکستری بسیار روشن */
            padding-bottom: 100px;
            overflow-x: hidden; /* جلوگیری از اسکرول افقی */
        }
        
        .metric-card {
            background-color: #ffffff;
            padding: 1rem; /* از 1.25rem کاهش یافت */
            border-radius: 20px; /* گوشه‌های بسیار گرد */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.07);
            border: none;
            transition: all 0.3s;
        }
        .metric-card:hover {
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.1);
            transform: translateY(-3px);
        }
        
        .auto-resize-textarea {
            overflow: hidden; 
            resize: none; 
            min-height: 120px;
            height: auto;
        }

        .nav-item.active {
            color: #4f46e5; /* رنگ اصلی اپ (Indigo) */
        }
        .nav-item.active span {
             font-weight: 700;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in-up {
            animation: fadeInUp 0.5s ease-out forwards;
            opacity: 0; 
        }

        @keyframes skeleton-pulse {
            0% { background-color: #f0f2f5; }
            50% { background-color: #e6e8eb; }
            100% { background-color: #f0f2f5; }
        }
        .skeleton-pulse {
            animation: skeleton-pulse 1.5s ease-in-out infinite;
            border-radius: 16px;
        }

        .btn-press {
            transition: transform 0.1s ease;
        }
        .btn-press:active {
            transform: scale(0.96); 
        }

        /* [جدید] استایل برای تب‌های فعال در صفحه تیکت‌ها */
        .ticket-tab.active {
            background-color: #4f46e5;
            color: #ffffff;
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.4);
        }

        /* [جدید] استایل برای حباب‌های چت */
        .chat-bubble {
            padding: 0.75rem 1rem;
            border-radius: 18px;
            max-width: 80%;
            word-wrap: break-word; /* Ensure long words break */
            overflow-wrap: break-word; /* Alternative for word-wrap */
            white-space: pre-wrap; /* Preserve whitespace and wrap */
        }
        .chat-bubble.user {
            background-color: #f0f2f5;
            color: #1f2937;
            border-bottom-right-radius: 4px;
        }
        .chat-bubble.admin {
            background-color: #4f46e5;
            color: #ffffff;
            border-bottom-left-radius: 4px;
        }

    </style>
</head>
<body class="antialiased">

    <!-- کانتینر اصلی اپلیکیشن -->
    <div id="app-container">
        <!-- هدر ثابت، ساده و سفید - شبیه به ویدیو -->
        <header class="bg-white text-gray-900 p-4 flex items-center shadow-sm sticky top-0 z-10">
            <!-- آیکون بازگشت -->
            <button id="back-button" class="text-gray-700 p-2 hover:bg-gray-100 rounded-full transition duration-150 hidden btn-press">
                <i data-lucide="chevron-right" class="h-6 w-6"></i>
            </button>
            <h1 id="header-title" class="text-lg font-extrabold mr-4 flex-grow truncate">پنل مدیریت ربات</h1>
        </header>

        <!-- کانتینر اصلی محتوا (padding و space-y کاهش یافت) -->
        <div id="content" class="p-4 space-y-4">
            <!-- لودر اولیه در اینجا قرار می‌گیرد -->
            <div id="loading-spinner" class="text-center p-8 mt-10">
                 <!-- این محتوا توسط render() یا renderDashboardSkeleton() جایگزین خواهد شد -->
            </div>
        </div>

        <!-- [جدید] فیلد ارسال پاسخ در صفحه تیکت (خارج از محتوا برای چسبیدن به پایین) -->
        <div id="reply-container" class="fixed bottom-0 left-0 right-0 bg-white p-4 shadow-[0_-5px_20px_rgba(0,0,0,0.05)] z-20 transform translate-y-full transition-transform duration-300">
            <div class="flex items-center space-x-3" dir="ltr">
                <button id="send-reply-btn" class="bg-indigo-600 text-white p-3 rounded-full btn-press shadow-lg shadow-indigo-300">
                    <i data-lucide="send" class="h-6 w-6"></i>
                </button>
                <textarea id="reply-textarea" rows="1" class="w-full p-3 border border-gray-300 rounded-2xl shadow-inner focus:border-indigo-500 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 transition duration-150 text-gray-800 text-sm" placeholder="پاسخ خود را بنویسید..." style="resize: none;"></textarea>
            </div>
        </div>

    </div>

    <!-- [جدید] نوار ناوبری پایین صفحه - سه‌بخشی -->
    <nav id="footer-nav" class="fixed bottom-0 left-0 right-0 bg-white shadow-[0_-5px_20px_rgba(0,0,0,0.05)] rounded-t-3xl h-20 flex justify-around items-center z-10">
        <button onclick="navigateTo('Dashboard', getDashboardTitle(STORE_HANDLE || MOCK_STORE_HANDLE))" id="nav-dashboard" class="nav-item btn-press flex flex-col items-center justify-center text-gray-500 w-1/3" data-page="Dashboard">
            <i data-lucide="layout-dashboard" class="h-6 w-6"></i>
            <span class="text-xs font-semibold mt-1">داشبورد</span>
        </button>
        <button onclick="navigateTo('TicketsList', 'لیست تیکت‌ها')" id="nav-tickets" class="nav-item btn-press flex flex-col items-center justify-center text-gray-500 w-1/3" data-page="TicketsList">
            <i data-lucide="inbox" class="h-6 w-6"></i>
            <span class="text-xs font-semibold mt-1">تیکت‌ها</span>
        </button>
        <button onclick="navigateTo('MainMenu', 'مدیریت متون')" id="nav-settings" class="nav-item btn-press flex flex-col items-center justify-center text-gray-500 w-1/3" data-page="MainMenu">
            <i data-lucide="settings" class="h-6 w-6"></i>
            <span class="text-xs font-semibold mt-1">تنظیمات</span>
        </button>
    </nav>


    <!-- پیام نمایش داده شده در پایین صفحه -->
    <div id="message-box" class="fixed bottom-24 left-4 right-4 p-4 text-white text-center rounded-2xl shadow-2xl z-20 hidden transform transition-all duration-300 translate-y-10 opacity-0">
        عملیات با موفقیت انجام شد!
    </div>

    <script>
        // --- تنظیمات مهم (WORKER & STORE) ---
        // ... (کد قبلی) ...
        const urlParams = new URLSearchParams(window.location.search);
        const STORE_HANDLE = urlParams.get('storeHandle');
        const MOCK_STORE_HANDLE = 'test-store-mock-dfdfdfd';

        // [جدید] اضافه کردن departmentMap در اینجا
        const departmentMap = {
            general: 'سوالات متفرقه',
            technical: 'پشتیبانی فنی',
            sales: 'بخش فروش',
            marketing: 'بازاریابی',
            ideas: 'ایده ها و پیشنهادات',
        };
        // [جدید] اضافه کردن statusMap در اینجا (برای استفاده احتمالی در آینده)
        const statusMap = {
            open: 'باز (در حال بررسی)',
            closed: 'بسته شده',
            pending_user_reply: 'در انتظار پاسخ شما',
        };


        // --- MOCK DATA ---
        const mockAppTexts = {
            greetingTitle: "سلام مدیر عزیز! 👋 (آزمایشی)",
            quickTipMessage: "💡 نکته: این متون برای تست در حالت آزمایشی بارگذاری شده‌اند.",
            faqButtonEnabled: "true",
            faqButtonText: "مشاهده سوالات متداول",
            faqUrl: "https://mock.faq.com/",
            navTickets: "تیکت‌ها",
            navNewTicket: "تیکت جدید",
            infoModalTitle: "راهنمای ارسال تیکت",
            infoModalTip: "لطفا ابتدا صفحه سوالات متداول را بررسی کنید.",
            closedTicketBanner: "این گفتگو توسط پشتیبانی بسته شده است.",
            submitNewTicketBtn: "ارسال",
            modalCloseBtn: "متوجه شدم",
            userReplyNotification: "✅ *پشتیبانی فنی* به تیکت شما با موضوع *مشکل اتصال* پاسخ داد.\\n\\nبرای مشاهده پاسخ کلیک کنید.",
            ticketClosedNotification: "🎫 تیکت شما با موضوع *پرداخت ناموفق* بسته شد.\\n\\nلطفا امتیاز دهید.",
        };
        const mockAppStats = {
            totalCount: '145',
            totalActive: '4',
            openCount: '3',
            pendingCount: '1',
            avgRating: '4.92',
            ratingPercentage: '88.5',
            ratedTicketsCount: 120,
            avgFirstResponseTime: '3 ساعت و 15 دقیقه',
            avgTimeToResolution: '1 روز و 5 ساعت',
        };

        // [جدید] داده‌های آزمایشی برای لیست تیکت‌ها
        const mockAppTickets = [
            { id: 'T1001', subject: 'مشکل در اتصال به سرور', user_name: 'کاربر ۱۲۳', status: 'open', department: 'technical', created_at: new Date(Date.now() - 5 * 60 * 1000).toISOString(), messages: [ // استفاده از user_name و technical
                { sender: 'user', text: 'سلام، من نمی‌توانم به سرور متصل شوم.', created_at: new Date(Date.now() - 5 * 60 * 1000).toISOString() },
                { sender: 'admin', text: 'سلام، لطفاً لحظاتی صبر کنید تا بررسی کنیم.', created_at: new Date(Date.now() - 4 * 60 * 1000).toISOString() },
                { sender: 'user', text: 'هنوز منتظرم.\n لطفاً سریع‌تر.', created_at: new Date(Date.now() - 3 * 60 * 1000).toISOString() }, // Added newline for testing
            ]},
            { id: 'T1002', subject: 'سوال در مورد تعرفه', user_name: 'کاربر ۴۵۶', status: 'open', department: 'sales', created_at: new Date(Date.now() - 60 * 60 * 1000).toISOString(), messages: [ // استفاده از user_name و sales
                { sender: 'user', text: 'سلام، تعرفه پلن حرفه‌ای چقدر است؟', created_at: new Date(Date.now() - 60 * 60 * 1000).toISOString() },
            ]},
            { id: 'T1003', subject: 'گزارش باگ', user_name: 'کاربر ۷۸۹', status: 'closed', department: 'technical', created_at: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(), messages: [ // استفاده از user_name و technical
                { sender: 'user', text: 'دکمه خروج کار نمی‌کند.', created_at: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString() },
                { sender: 'admin', text: 'ممنون از گزارش شما، در نسخه بعدی رفع خواهد شد. تیکت بسته شد.', created_at: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString() },
            ]},
        ];

        // [جدید] داده‌های آزمایشی برای نمودارها
        const mockChartData = {
            ratings: {
                labels: ['۵ ستاره', '۴ ستاره', '۳ ستاره', '۲ ستاره', '۱ ستاره'],
                data: [100, 15, 3, 1, 1], // 120 امتیاز
            },
            volume: {
                labels: ['شنبه', '۱شنبه', '۲شنبه', '۳شنبه', '۴شنبه', '۵شنبه', 'جمعه'],
                data: [5, 8, 3, 12, 10, 15, 7],
            }
        };

        const WORKER_API_BASE_URL = 'https://ticketing.amiruserbot7.workers.dev';
        const getDashboardTitle = (handle) => `داشبورد (${handle || 'ناشناس'})`;

        // --- پایان تنظیمات ---

        const content = document.getElementById('content');
        const backButton = document.getElementById('back-button');
        const headerTitle = document.getElementById('header-title');
        const messageBox = document.getElementById('message-box');
        // [جدید] کانتینر و فیلد پاسخ
        const replyContainer = document.getElementById('reply-container');
        const replyTextarea = document.getElementById('reply-textarea');

        let currentState = 'Dashboard-Loading';
        const history = [];
        let appTexts = {};
        let appStats = {};
        let appTickets = []; // [جدید] اکنون به درستی یک آرایه خواهد بود
        let chartData = {};  // [جدید]
        let currentTicketListFilter = 'open'; // [جدید]
        let currentEditKey = null;
        let successMessage = null;

        // [جدید] متغیرهای چارت‌ها برای جلوگیری از رندر تکراری
        let ratingChartInstance = null;
        let volumeChartInstance = null;

        const CUSTOM_TEXT_KEYS = {
            MINI_APP_UI: {
                greetingTitle: { name: "عنوان خوش‌آمدگویی", icon: "user-check", desc: `متن اصلی کارت راهنما (مثلاً: سلام مشتری عزیز!)` },
                quickTipMessage: { name: "پیام راهنمای سریع", icon: "lightbulb", desc: `متن کوچک زیر عنوان در کارت راهنما (مثلاً: لطفا مشکل را با جزئیات بنویسید)` },
                faqButtonEnabled: { name: "وضعیت دکمه راهنما", icon: "toggle-right", desc: `دکمه سوالات متداول را در مینی‌اپ فعال یا غیرفعال کنید.`, isBoolean: true },
                faqButtonText: { name: "متن دکمه راهنما", icon: "help-circle", desc: `متنی که روی دکمه مشاهده سوالات متداول نمایش داده می‌شود.` },
                faqUrl: { name: "لینک دکمه راهنما", icon: "link", desc: `آدرس URL کامل (باید با https:// شروع شود).`, isUrl: true },
                navTickets: { name: "منوی: تیکت‌ها", icon: "ticket", desc: `متن آیکون تیکت‌ها در نوار پایین مینی‌اپ.` },
                navNewTicket: { name: "منوی: تیکت جدید", icon: "file-plus", desc: `متن آیکون ایجاد تیکت جدید در نوار پایین مینی‌اپ.` },
                infoModalTitle: { name: "عنوان راهنمای تیکت", icon: "info", desc: `عنوان پنجره‌ای که قبل از ثبت تیکت جدید نمایش داده می‌شود.` },
                infoModalTip: { name: "پیام راهنمای مودال", icon: "message-square-text", desc: `متن اصلی داخل پنجره راهنما قبل از ثبت تیکت.` },
                closedTicketBanner: { name: "بنر تیکت بسته شده", icon: "lock", desc: `متنی که در پایین یک تیکت بسته شده نمایش داده می‌شود.` },
                submitNewTicketBtn: { name: "متن دکمه ارسال", icon: "send", desc: `متنی که روی دکمه 'ارسال' تیکت جدید نمایش داده می‌شود.` },
                modalCloseBtn: { name: "متن دکمه متوجه شدم", icon: "x-circle", desc: `متن دکمه بستن پنجره‌های مودال.` },
            },
            USER_NOTIFICATIONS: {
                userReplyNotification: { name: "اعلان پاسخ ادمین", icon: "bell-plus", desc: `متنی که پس از پاسخ ادمین، برای کاربر ارسال می‌شود. این متن از متغیرهای پویا پشتیبانی می‌کند.` },
                ticketClosedNotification: { name: "اعلان بسته شدن تیکت", icon: "bell-off", desc: `متنی که پس از بستن تیکت، برای کاربر ارسال می‌شود. این متن از متغیرهای پویا پشتیبانی می‌کند.` },
            }
        };

        // --- توابع کمکی ---

        function autoResize(el) {
            el.style.height = 'auto';
            el.style.height = (el.scrollHeight) + 'px';
        }

        function getFullKeyData(key) {
            for (const menuType in CUSTOM_TEXT_KEYS) {
                if (CUSTOM_TEXT_KEYS[menuType][key]) {
                    return { type: menuType, key, ...CUSTOM_TEXT_KEYS[menuType][key] };
                }
            }
            return null;
        }
        function showMessage(text, type = 'success', duration = 4000) {
            messageBox.textContent = text;
            messageBox.className = `fixed bottom-24 left-4 right-4 p-4 text-white text-center rounded-2xl shadow-2xl z-20 transform transition-all duration-300 ${type === 'success' ? 'bg-green-600' : 'bg-red-600'}`;

            setTimeout(() => {
                messageBox.classList.remove('hidden', 'translate-y-10', 'opacity-0');
            }, 10);

            setTimeout(() => {
                messageBox.classList.add('translate-y-10', 'opacity-0');
                setTimeout(() => messageBox.classList.add('hidden'), 300);
            }, duration);
        }

        // [جدید] نمایش یا پنهان کردن فیلد پاسخ
        function showReplyContainer(show) {
            const bodyPadding = show ? '180px' : '100px'; // فضا برای نوار پایین + فیلد پاسخ
            document.body.style.paddingBottom = bodyPadding;

            if(show) {
                replyContainer.classList.remove('translate-y-full');
            } else {
                replyContainer.classList.add('translate-y-full');
            }
        }


        // [به‌روزرسانی] تابع به‌روزرسانی نوار ناوبری پایین
        function updateFooterNav(state) {
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active', 'text-indigo-600');
                item.classList.add('text-gray-500');
            });

            let activeItem;
            if (state === 'Dashboard' || state === 'Dashboard-Loading') {
                activeItem = document.getElementById('nav-dashboard');
            } else if (state === 'TicketsList' || state.startsWith('TicketView_')) { // [جدید]
                activeItem = document.getElementById('nav-tickets');
            } else if (state === 'MainMenu' || state.startsWith('SubMenu_') || state.startsWith('EditScreen_')) {
                activeItem = document.getElementById('nav-settings');
            }

            if (activeItem) {
                activeItem.classList.add('active', 'text-indigo-600');
                activeItem.classList.remove('text-gray-500');
            }
        }

        // [به‌روزرسانی] تابع ناوبری
        function navigateTo(newState, title = null, pushHistory = true) {
            if (pushHistory && currentState !== 'Dashboard-Loading') {
                history.push(currentState);
            }
            currentState = newState;

            const currentHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            const dashboardTitle = getDashboardTitle(currentHandle);

            headerTitle.textContent = title || dashboardTitle;
            updateFooterNav(newState);

            // [جدید] نمایش/پنهان کردن فیلد پاسخ بر اساس صفحه
            if (currentState.startsWith('TicketView_')) {
                showReplyContainer(true);
            } else {
                showReplyContainer(false);
            }

            render();
            window.scrollTo(0, 0);
        }

        // [به‌روزرسانی] تابع بازگشت
        function handleBack() {
            if (currentState.startsWith('EditScreen_')) {
                currentEditKey = null;
            }
            // [جدید] پنهان کردن فیلد پاسخ هنگام بازگشت
            if (currentState.startsWith('TicketView_')) {
                 showReplyContainer(false);
            }

            if (history.length > 0) {
                const previousState = history.pop();

                const currentHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
                const dashboardTitle = getDashboardTitle(currentHandle);

                let title = dashboardTitle;
                if (previousState === 'MainMenu') title = 'مدیریت متون';
                if (previousState === 'TicketsList') title = 'لیست تیکت‌ها'; // [جدید]
                if (previousState.startsWith('SubMenu_')) {
                    const menuType = previousState.replace('SubMenu_', '');
                    title = menuType === 'MINI_APP_UI' ? 'متن‌های مینی‌اپ' : 'متن‌های اعلان ربات';
                }

                currentState = previousState;
                headerTitle.textContent = title;
                updateFooterNav(previousState);
                render(false);
                window.scrollTo(0, 0);
            } else {
                navigateTo('Dashboard', getDashboardTitle(STORE_HANDLE || MOCK_STORE_HANDLE), false);
            }
        }

        // --- Data Fetching (از Worker API) ---
        async function fetchStats() {
            const currentStoreHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            if (currentStoreHandle === MOCK_STORE_HANDLE) return mockAppStats;

            const url = `${WORKER_API_BASE_URL}/api/${currentStoreHandle}/stats`;
            const response = await fetch(url);
            if (!response.ok) throw new Error('Failed to fetch stats from Worker.');
            const result = await response.json();
            if (!result.success) throw new Error(result.error || 'Worker stats returned error.');
            return result.data;
        }
        async function fetchAppTexts() {
            const currentStoreHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            if (currentStoreHandle === MOCK_STORE_HANDLE) return mockAppTexts;

            const url = `${WORKER_API_BASE_URL}/api/${currentStoreHandle}/texts`;
            const response = await fetch(url);
            if (!response.ok) throw new Error('Worker failed to fetch texts.');
            const result = await response.json();
            if (!result.success) throw new Error(result.error || 'Worker texts returned error.');
            return result.data;
        }

        // [اصلاح شد] تابع واکشی تیکت‌ها برای تبدیل آبجکت به آرایه
        async function fetchTickets() {
            const currentStoreHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            if (currentStoreHandle === MOCK_STORE_HANDLE) {
                 console.log("Fetching mock tickets");
                 return mockAppTickets; // داده mock از قبل آرایه است
            }

            const url = `${WORKER_API_BASE_URL}/api/${currentStoreHandle}/tickets`;
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to fetch tickets from Worker (${response.status})`);
                const result = await response.json();
                if (!result.success) throw new Error(result.error || 'Worker tickets returned error.');

                // -----------------------------------------------------------------
                // [اصلاح حیاتی] تبدیل آبجکت به آرایه
                // -----------------------------------------------------------------
                const ticketsObject = result.data || {};
                const ticketsArray = Object.keys(ticketsObject).map(key => {
                    // آبجکت تیکت را با 'id' که همان کلید فایربیس است، ترکیب می‌کنیم
                    return {
                        id: key,
                        ...ticketsObject[key]
                    };
                });

                console.log("Fetched and converted tickets:", ticketsArray); // برای دیباگ
                return ticketsArray; // بازگشت آرایه اصلاح شده
                // -----------------------------------------------------------------

            } catch (error) {
                console.error("Error fetching real tickets:", error.message);
                showMessage(`❌ خطا در واکشی لیست تیکت‌ها: ${error.message}.`, 'error');
                return []; // بازگشت آرایه خالی در صورت خطا
            }
        }

        // [جدید] تابع واکشی داده‌های نمودار
        async function fetchChartData() {
            // [اصلاح شد] اکنون داده‌های واقعی را واکشی می‌کند
            const currentStoreHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
             if (currentStoreHandle === MOCK_STORE_HANDLE) {
                 console.log("Fetching mock chart data");
                 return mockChartData;
             }

            const url = `${WORKER_API_BASE_URL}/api/${currentStoreHandle}/chartdata`; // فرض بر این است که این endpoint داده‌های نمودار است
             try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to fetch chart data from Worker.');
                const result = await response.json();
                if (!result.success) throw new Error(result.error || 'Worker chart data returned error.');
                // اطمینان از اینکه ساختار داده با داده‌های آزمایشی مطابقت دارد
                return {
                    ratings: result.data.ratings || { labels: [], data: [] },
                    volume: result.data.volume || { labels: [], data: [] }
                };
            } catch (error) {
                console.error("Error fetching real chart data:", error.message);
                showMessage(`❌ خطا در واکشی داده‌های نمودار: ${error.message}.`, 'error');
                // بازگشت ساختار خالی در صورت خطا
                return {
                    ratings: { labels: [], data: [] },
                    volume: { labels: [], data: [] }
                };
            }
        }


        // [به‌روزرسانی] تابع واکشی داده‌های اولیه
        async function fetchInitialData() {
            currentState = 'Dashboard-Loading';
            render();

            try {
                // [اصلاح شد] دیگر در صورت نبودن STORE_HANDLE خطا نمی‌دهد، فقط به حالت آزمایشی می‌رود
                const isMockMode = !STORE_HANDLE;

                if (isMockMode) {
                    console.warn("Missing STORE_HANDLE, loading mock data.");
                    appTexts = mockAppTexts;
                    appStats = mockAppStats;
                    appTickets = mockAppTickets;
                    chartData = mockChartData;
                } else {
                     // [جدید] واکشی تمام داده‌ها به صورت موازی
                    const [textsData, statsData, ticketsData, chartApiData] = await Promise.all([
                        fetchAppTexts(),
                        fetchStats(),
                        fetchTickets(), // این تابع اکنون آرایه برمی‌گرداند
                        fetchChartData()
                    ]);

                    appTexts = textsData;
                    appStats = statsData;
                    appTickets = ticketsData; // اکنون ticketsData یک آرایه است
                    chartData = chartApiData;
                }

            } catch (error) {
                console.error(`Error in fetchInitialData: ${error.message}. Loading mock data as fallback...`);
                appTexts = mockAppTexts;
                appStats = mockAppStats;
                appTickets = mockAppTickets;
                chartData = mockChartData;
                showMessage(`❌ خطا در اتصال به API: ${error.message.substring(0, 50)}... بارگذاری داده آزمایشی.`, 'error');
            }

            currentState = 'Dashboard';
            updateFooterNav('Dashboard');
            render();
        }

        // --- Data Persistence (از طریق Worker API) ---
        async function handleSave() {
            const saveButton = document.getElementById('save-button');
            const editElement = document.getElementById('edit-area');
            const newText = editElement.value;

            if (!currentEditKey) return;
            const keyData = getFullKeyData(currentEditKey);

            if (keyData.isUrl) {
                if (!newText.startsWith('https://')) {
                    showMessage('❌ لینک باید با https:// شروع شود.', 'error', 5000);
                    return;
                }
            }

            saveButton.disabled = true;
            saveButton.innerHTML = '<i data-lucide="loader-circle" class="animate-spin h-5 w-5 inline mr-2"></i> در حال ذخیره...';
            lucide.createIcons();

            const currentStoreHandle = STORE_HANDLE || MOCK_STORE_HANDLE;

            if (currentStoreHandle === MOCK_STORE_HANDLE) {
                appTexts[currentEditKey] = newText;
                successMessage = `✅ تنظیم "${keyData.name}" با موفقیت در حالت آزمایشی ذخیره شد!`;

                navigateTo(`SubMenu_${keyData.type}`, 'مدیریت متون');
                return;
            }

            const url = `${WORKER_API_BASE_URL}/api/${currentStoreHandle}/texts`;
            const payload = { [currentEditKey]: newText };

            try {
                const response = await fetch(url, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    appTexts[currentEditKey] = newText;
                    successMessage = `✅ تنظیم "${keyData.name}" با موفقیت ذخیره و اعمال شد!`;

                    navigateTo(`SubMenu_${keyData.type}`, 'مدیریت متون');
                } else {
                    throw new Error(result.error || 'خطا در Worker API هنگام ذخیره.');
                }
            } catch (error) {
                console.error("Error saving text via Worker:", error);
                showMessage(`❌ خطا در ذخیره تنظیم: ${error.message}`, 'error');
            } finally {
                saveButton.disabled = false;
                saveButton.innerHTML = '<i data-lucide="save" class="h-5 w-5 inline ml-1"></i> ذخیره تغییرات';
                lucide.createIcons();
            }
        }

        // =================================================================
        // RENDER FUNCTIONS (UI) - بازطراحی شده
        // =================================================================

        // [به‌روزرسانی] تابع رندر لودر اسکلتی
        function renderDashboardSkeleton() {
            backButton.classList.add('hidden');
            const currentHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            headerTitle.textContent = getDashboardTitle(currentHandle);

            content.innerHTML = `
                <div class="space-y-4 animate-pulse">
                    <h2 class="text-2xl font-extrabold text-gray-800 border-b pb-2 mb-3">گزارش عملکرد</h2>

                    <!-- Skeleton for Metric Cards -->
                    <div class="grid grid-cols-2 gap-3">
                        <div class="skeleton-pulse h-24"></div>
                        <div class="skeleton-pulse h-24"></div>
                        <div class="skeleton-pulse h-24"></div>
                        <div class="skeleton-pulse h-24"></div>
                    </div>

                    <!-- [جدید] Skeleton for KPI Card (بزرگتر برای نمودارها) -->
                    <div class="skeleton-pulse w-full h-80"></div>

                    <!-- Skeleton for Button -->
                    <div class="skeleton-pulse w-full h-16 mt-3"></div>
                </div>
            `;
        }


        // [به‌روزرسانی] تابع رندر داشبورد
        function renderDashboard() {
            backButton.classList.add('hidden');
            const currentHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            headerTitle.textContent = getDashboardTitle(currentHandle);
            const stats = appStats;

            // ... (کد قبلی پیام موفقیت و progressBarColor) ...
            if (successMessage) {
                showMessage(successMessage);
                successMessage = null;
            }
            const ratingPercent = parseFloat(stats.ratingPercentage || '0');
            const progressBarColor = ratingPercent >= 90 ? 'bg-green-500' :
                                       ratingPercent >= 75 ? 'bg-yellow-500' : 'bg-red-500';


            const metricCards = [
                { title: "کل تیکت‌ها", value: stats.totalCount || '0', icon: "ticket", color: "text-indigo-600", desc: "تعداد کل تیکت‌های ثبت شده." },
                { title: "تیکت‌های فعال", value: stats.totalActive || '0', icon: "inbox", color: "text-red-600", desc: "باز و در انتظار پاسخ ادمین." },
                { title: "امتیاز میانگین", value: `${stats.avgRating || 'N/A'} / 5.00`, icon: "star", color: "text-yellow-600", desc: `بر اساس ${stats.ratedTicketsCount || 0} امتیاز.` },
                { title: "میانگین پاسخ", value: stats.avgFirstResponseTime || 'N/A', icon: "clock-3", color: "text-green-600", desc: "زمان متوسط اولین پاسخ." },
            ];

            content.innerHTML = `
                <div class="space-y-4">

                    <h2 class="text-2xl font-extrabold text-gray-800 border-b pb-2 mb-3 fade-in-up" style="animation-delay: 100ms;">گزارش عملکرد</h2>

                    <div class="grid grid-cols-2 gap-3">
                        ${metricCards.map((card, index) => `
                            <div class="metric-card fade-in-up" style="animation-delay: ${150 + index * 50}ms;">
                                <div class="flex items-center justify-between mb-3">
                                    <h3 class="text-sm font-semibold text-gray-500">${card.title}</h3>
                                    <i data-lucide="${card.icon}" class="${card.color} h-6 w-6"></i>
                                </div>
                                <p class="text-2xl font-extrabold text-gray-900">${card.value}</p>
                                <p class="text-xs text-gray-400 mt-1 truncate">${card.desc}</p>
                            </div>
                        `).join('')}
                    </div>

                    <!-- [جدید] کارت KPI و نمودارها -->
                    <div class="metric-card bg-white fade-in-up" style="animation-delay: 350ms;">
                        <h3 class="text-lg font-bold text-gray-800 mb-3 flex items-center">
                            <i data-lucide="zap" class="h-5 w-5 ml-2 text-purple-600"></i> شاخص‌های کلیدی (KPI)
                        </h3>
                        <div class="space-y-3">
                            <p class="flex justify-between text-sm">
                                <span class="text-gray-600">زمان حل نهایی تیکت:</span>
                                <span class="font-bold text-gray-800">${stats.avgTimeToResolution || 'N/A'}</span>
                            </p>
                            <div>
                                <p class="flex justify-between text-sm mb-1">
                                    <span class="text-gray-600">درصد رضایت کاربران:</span>
                                    <span class="font-bold text-gray-800">${stats.ratingPercentage || '0.0'}%</span>
                                </p>
                                <div class="w-full bg-gray-200 rounded-full h-2.5 overflow-hidden">
                                    <div class="${progressBarColor} h-2.5 rounded-full transition-all duration-500" style="width: ${ratingPercent > 100 ? 100 : ratingPercent}%;"></div>
                                </div>
                            </div>
                        </div>

                        <!-- [جدید] بخش نمودارها -->
                        <div class="mt-6 border-t pt-4">
                            <!-- نمودار دایره‌ای -->
                            <h4 class="text-base font-bold text-gray-700 mb-2">تفکیک امتیازات</h4>
                            <div class="w-full max-w-xs mx-auto h-48">
                                <canvas id="ratingChart"></canvas>
                            </div>
                            <!-- نمودار خطی -->
                            <h4 class="text-base font-bold text-gray-700 mt-6 mb-2">حجم تیکت (۷ روز گذشته)</h4>
                            <div class="w-full h-48">
                                <canvas id="volumeChart"></canvas>
                            </div>
                        </div>
                    </div>

                    <button onclick="navigateTo('MainMenu', 'مدیریت متون')" class="w-full bg-white text-gray-900 py-4 mt-3 rounded-2xl shadow-lg hover:shadow-xl transition duration-300 font-bold flex items-center justify-center text-base btn-press fade-in-up" style="animation-delay: 400ms;">
                        <i data-lucide="settings" class="h-6 w-6 ml-2 text-indigo-600"></i>
                        مدیریت متون و تنظیمات
                    </button>
                </div>
            `;

            // [جدید] رندر کردن نمودارها پس از رندر HTML
            // [اصلاح شد] تاخیر کوتاه برای اطمینان از رندر شدن canvas
            setTimeout(() => {
                initRatingChart();
                initVolumeChart();
            }, 100);
        }

        // [جدید] تابع رندر لیست تیکت‌ها
        function renderTicketsList() {
            backButton.classList.add('hidden'); // صفحه اصلی تب تیکت‌ها دکمه بازگشت ندارد
            headerTitle.textContent = 'لیست تیکت‌ها';

            if (successMessage) {
                showMessage(successMessage);
                successMessage = null;
            }

            // [اصلاح شد] اکنون appTickets یک آرایه است و این کد به درستی کار می‌کند
            const filteredTickets = appTickets.filter(t => t.status === currentTicketListFilter);
            const openTicketsCount = appTickets.filter(t => t.status === 'open').length;
            const closedTicketsCount = appTickets.filter(t => t.status === 'closed').length;


            content.innerHTML = `
                <div class="fade-in-up">
                    <!-- [جدید] تب‌های فیلتر -->
                    <div class="flex items-center justify-center space-x-2 space-x-reverse bg-gray-200 p-1 rounded-full mb-5">
                        <button onclick="filterTickets('open')" class="ticket-tab w-full text-center px-4 py-2 rounded-full font-semibold transition-all duration-300 ${currentTicketListFilter === 'open' ? 'active' : 'text-gray-700'}">
                            باز (${openTicketsCount})
                        </button>
                        <button onclick="filterTickets('closed')" class="ticket-tab w-full text-center px-4 py-2 rounded-full font-semibold transition-all duration-300 ${currentTicketListFilter === 'closed' ? 'active' : 'text-gray-700'}">
                            بسته (${closedTicketsCount})
                        </button>
                    </div>

                    <!-- [جدید] لیست تیکت‌ها -->
                    <div class="space-y-4">
                        ${filteredTickets.length > 0 ? filteredTickets.map((ticket, index) => `
                            <div class="bg-white rounded-2xl shadow-lg p-4 cursor-pointer transition duration-200 hover:shadow-xl btn-press fade-in-up" style="animation-delay: ${50 + index * 50}ms;" onclick="navigateTo('TicketView_${ticket.id}', '${ticket.subject}')">
                                <div class="flex items-center justify-between mb-2">
                                    <span class="font-bold text-gray-800 text-base truncate">${ticket.subject || 'بدون موضوع'}</span>
                                    <!-- [اصلاح شد] نمایش زمان ایجاد با فرمت بهتر -->
                                    <span class="text-xs font-semibold text-gray-500">${new Date(ticket.created_at).toLocaleTimeString('fa-IR', { hour: '2-digit', minute: '2-digit' }) || ''}</span>
                                </div>
                                <div class="flex items-center justify-between text-sm">
                                     <!-- [اصلاح شد] نمایش user_name اگر وجود دارد -->
                                    <span class="text-gray-600">${ticket.user_name || 'کاربر ناشناس'}</span>
                                    <!-- [اصلاح شد] استفاده از departmentMap تعریف شده در همین فایل -->
                                     <span class="text-xs font-semibold ${
                                        ticket.department === 'technical' ? 'bg-blue-100 text-blue-700' :
                                        ticket.department === 'sales' ? 'bg-green-100 text-green-700' :
                                        ticket.department === 'marketing' ? 'bg-purple-100 text-purple-700' :
                                        ticket.department === 'ideas' ? 'bg-yellow-100 text-yellow-700' :
                                        'bg-gray-100 text-gray-700' // Default for general or unknown
                                    } px-2 py-0.5 rounded-full">${
                                        departmentMap[ticket.department] || ticket.department || 'عمومی' // استفاده از departmentMap
                                    }</span>
                                </div>
                            </div>
                        `).join('') : `
                            <div class="text-center text-gray-500 pt-10 fade-in-up">
                                <i data-lucide="inbox" class="h-12 w-12 mx-auto text-gray-400"></i>
                                <p class="mt-2 font-semibold">هیچ تیکت ${currentTicketListFilter === 'open' ? 'بازی' : 'بسته‌ای'} یافت نشد.</p>
                            </div>
                        `}
                    </div>
                </div>
            `;
        }

        // [جدید] تابع برای تغییر فیلتر تیکت‌ها
        function filterTickets(status) {
            currentTicketListFilter = status;
            render(); // رندر مجدد صفحه تیکت‌ها
        }

        // [جدید] تابع رندر صفحه مشاهده تیکت
        function renderTicketView(state) {
            backButton.classList.remove('hidden'); // نمایش دکمه بازگشت
            const ticketId = state.replace('TicketView_', '');
            // [اصلاح شد] اکنون appTickets یک آرایه است و .find() کار می‌کند
            const ticket = appTickets.find(t => t.id === ticketId);

            if (!ticket) {
                content.innerHTML = `<p class="text-red-600 p-4 font-bold">خطا: تیکت یافت نشد.</p>`;
                return;
            }

            headerTitle.textContent = ticket.subject;

             // [اصلاح مهم] واکشی پیام‌های واقعی برای تیکت
             // ما دیگر به ticket.messages در آبجکت اصلی تکیه نمی‌کنیم
             // تابع fetchMessagesForTicket مسئول آپدیت UI خواهد بود
             fetchMessagesForTicket(ticketId);

             // نمایش موقت لودر یا پیام "در حال بارگذاری پیام‌ها..."
             // [اصلاح شد] استفاده از departmentMap و statusMap
             content.innerHTML = `
                 <div class="space-y-4 fade-in-up" style="padding-bottom: 80px;"> <!-- Add padding for reply box -->
                     <!-- اطلاعات تیکت -->
                     <div class="bg-white rounded-2xl shadow-lg p-4 text-sm">
                          <p><strong>کاربر:</strong> ${ticket.user_name || 'کاربر ناشناس'}</p>
                          <p><strong>دپارتمان:</strong> ${departmentMap[ticket.department] || ticket.department || 'عمومی'}</p>
                          <p><strong>وضعیت:</strong> ${statusMap[ticket.status] || ticket.status || 'نامشخص'}</p>
                     </div>
                     <!-- کانتینر پیام‌ها -->
                     <div id="messages-container" class="space-y-3">
                         <!-- لودر اولیه پیام‌ها -->
                         <div class="text-center text-gray-500 pt-5">
                            <i data-lucide="loader-circle" class="animate-spin h-8 w-8 mx-auto text-indigo-600"></i>
                            <p>در حال بارگذاری پیام‌ها...</p>
                         </div>
                     </div>
                 </div>
             `;
             // Make sure icons render even in loading state
            lucide.createIcons();
        }

       // [جدید و اصلاح شده] تابع واکشی و رندر پیام‌ها برای یک تیکت خاص
       async function fetchMessagesForTicket(ticketId) {
            const messagesContainer = document.getElementById('messages-container');
            // اطمینان از اینکه در صفحه درست هستیم و کانتینر وجود دارد
            if (!messagesContainer || currentState !== `TicketView_${ticketId}`) {
                console.log("Not rendering messages - wrong state or container not found");
                return;
            }

            const currentStoreHandle = STORE_HANDLE || MOCK_STORE_HANDLE;

            // --- حالت آزمایشی ---
            if (currentStoreHandle === MOCK_STORE_HANDLE) {
                console.log("Mock mode: Loading messages from mock ticket object.");
                const ticket = mockAppTickets.find(t => t.id === ticketId);
                // اطمینان از اینکه پیام‌ها وجود دارند قبل از رندر
                const messages = ticket?.messages?.sort((a, b) => new Date(a.created_at) - new Date(b.created_at)) || [];
                renderMessages(messages, messagesContainer); // رندر پیام‌های mock
                lucide.createIcons(); // رندر آیکون‌ها اگر در پیام‌ها استفاده شود
                // اسکرول به پایین بعد از رندر پیام‌های mock
                 setTimeout(() => {
                    if (messagesContainer) { // Double check container exists
                      messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    }
                 }, 50); // Small delay to ensure DOM update
                return;
            }
            // --- پایان حالت آزمایشی ---

            const url = `${WORKER_API_BASE_URL}/api/${currentStoreHandle}/messages?ticket_id=${ticketId}`;
            try {
                console.log(`Fetching messages from: ${url}`); // Log fetch attempt
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to fetch messages (${response.status})`);
                const result = await response.json();
                 console.log("Messages API response:", result); // Log API response
                if (!result.success) throw new Error(result.error || 'Worker messages returned error.');

                // تبدیل آبجکت پیام‌ها به آرایه و مرتب‌سازی بر اساس زمان
                const messagesObject = result.data || {};
                const messagesArray = Object.values(messagesObject).sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                 console.log("Sorted messages array:", messagesArray); // Log sorted array

                // رندر کردن پیام‌ها در کانتینر
                renderMessages(messagesArray, messagesContainer);

            } catch (error) {
                console.error("Error fetching messages:", error.message);
                showMessage(`❌ خطا در واکشی پیام‌ها: ${error.message}.`, 'error');
                 if (messagesContainer) {
                    messagesContainer.innerHTML = `<p class="text-red-600 p-4 font-bold text-center">خطا در بارگذاری پیام‌ها.</p>`;
                 }
            } finally {
                 // اطمینان از رندر شدن آیکون‌ها حتی در صورت خطا
                 lucide.createIcons();
                 // اسکرول به پایین بعد از رندر یا خطا
                 setTimeout(() => {
                    if (messagesContainer) {
                        console.log("Scrolling messages container to bottom"); // Log scroll attempt
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    }
                 }, 50); // Small delay for DOM update
            }
        }

        // [جدید] تابع کمکی برای رندر کردن آرایه پیام‌ها در DOM
        function renderMessages(messagesArray, containerElement) {
            console.log("Rendering messages:", messagesArray); // Log messages being rendered
            if (!containerElement) {
                 console.error("Cannot render messages: containerElement is null");
                 return;
            }

            if (messagesArray.length === 0) {
                 containerElement.innerHTML = `<p class="text-gray-500 text-center pt-5">هنوز پیامی رد و بدل نشده است.</p>`;
                 return;
             }
             // Ensure text exists and replace newlines
            const sanitizeText = (text = '') => text.replace(/\n/g, '<br>');

            containerElement.innerHTML = messagesArray.map(msg => `
                <div class="flex ${msg.sender === 'admin' ? 'justify-start' : 'justify-end'} fade-in-up" style="animation-delay: ${messagesArray.indexOf(msg) * 30}ms"> <!-- Simple animation -->
                    <div class="chat-bubble ${msg.sender === 'admin' ? 'admin' : 'user'}">
                        ${
                            // نمایش Placeholder برای تصاویر
                            msg.type === 'image_placeholder'
                            ? `<span class="italic text-gray-500">${sanitizeText(msg.text)}</span>`
                            : sanitizeText(msg.text) // نمایش متن معمولی
                         }
                         <!-- نمایش زمان ارسال پیام -->
                         <div class="text-xs ${msg.sender === 'admin' ? 'text-indigo-200' : 'text-gray-400'} mt-1 text-left">${new Date(msg.created_at).toLocaleTimeString('fa-IR', { hour: '2-digit', minute: '2-digit' })}</div>
                    </div>
                </div>
            `).join('');
            console.log("Messages rendered to DOM"); // Confirm rendering
         }



        function renderMainMenu() {
            backButton.classList.remove('hidden');
            headerTitle.textContent = 'مدیریت متون';

            if (successMessage) {
                showMessage(successMessage);
                successMessage = null;
            }

            content.innerHTML = `
                <h2 class="text-2xl font-extrabold text-gray-800 mb-2 fade-in-up">شخصی‌سازی محتوا</h2>
                <p class="text-sm text-gray-500 mb-6 fade-in-up" style="animation-delay: 50ms;">متون کلیدی مینی اپ و اعلان‌های ربات را ویرایش کنید.</p>

                <div class="space-y-4">
                    <div class="bg-white rounded-2xl shadow-lg p-5 cursor-pointer transition duration-200 hover:shadow-xl btn-press fade-in-up" style="animation-delay: 100ms;" onclick="navigateTo('SubMenu_MINI_APP_UI', 'متن‌های مینی‌اپ')">
                        <div class="flex items-center justify-between">
                            <span class="flex items-center font-bold text-gray-800 text-base">
                                <i data-lucide="smartphone" class="h-6 w-6 ml-3 text-indigo-600"></i>
                                متن‌های مینی‌اپ
                            </span>
                            <i data-lucide="chevron-left" class="h-5 w-5 text-gray-400"></i>
                        </div>
                        <p class="text-sm text-gray-500 mt-2 pr-9">ویرایش رابط کاربری و پیام‌های داخل مینی‌اپ.</p>
                    </div>

                    <div class="bg-white rounded-2xl shadow-lg p-5 cursor-pointer transition duration-200 hover:shadow-xl btn-press fade-in-up" style="animation-delay: 150ms;" onclick="navigateTo('SubMenu_USER_NOTIFICATIONS', 'متن‌های اعلان ربات')">
                        <div class="flex items-center justify-between">
                            <span class="flex items-center font-bold text-gray-800 text-base">
                                <i data-lucide="bell" class="h-6 w-6 ml-3 text-orange-600"></i>
                                متن‌های اعلان کاربر
                            </span>
                            <i data-lucide="chevron-left" class="h-5 w-5 text-gray-400"></i>
                        </div>
                        <p class="text-sm text-gray-500 mt-2 pr-9">ویرایش پیام‌هایی که ربات برای کاربران ارسال می‌کند.</p>
                    </div>
                </div>
            `;
        }
        function renderSubMenu_Texts(state) {
            backButton.classList.remove('hidden');
            const menuType = state.replace('SubMenu_', '');
            const keys = CUSTOM_TEXT_KEYS[menuType];
            const menuTitle = menuType === 'MINI_APP_UI' ? "متن‌های مینی‌اپ" : "متن‌های اعلان ربات";

            headerTitle.textContent = menuTitle;

            if (successMessage) {
                showMessage(successMessage);
                successMessage = null;
            }

            content.innerHTML = `
                <h2 class="text-2xl font-extrabold text-gray-800 mb-2 fade-in-up">${menuTitle}</h2>
                <p class="text-sm text-gray-500 mb-6 fade-in-up" style="animation-delay: 50ms;">متن مورد نظر برای ویرایش را انتخاب کنید:</p>

                <div class="space-y-4">
                    ${Object.entries(keys).map(([key, data], index) => {
                        const menuIcon = data.icon || 'file-text';
                        const iconColor = menuType === 'MINI_APP_UI' ? 'text-indigo-500' : 'text-orange-500';

                        let additionalInfo = '';
                        if (data.isBoolean) {
                            const currentValue = (appTexts[key] === "true" || typeof appTexts[key] === 'undefined'); // Default to true if undefined
                            additionalInfo = currentValue
                                ? `<span class="text-xs font-semibold bg-green-100 text-green-700 px-2 py-0.5 rounded-full">فعال</span>`
                                : `<span class="text-xs font-semibold bg-gray-100 text-gray-600 px-2 py-0.5 rounded-full">غیرفعال</span>`;
                        }

                        return `
                            <div class="bg-white rounded-2xl shadow-lg p-5 cursor-pointer transition duration-200 hover:shadow-xl btn-press fade-in-up" style="animation-delay: ${100 + index * 50}ms;" onclick="navigateTo('EditScreen_${key}', 'ویرایش: ${data.name}')">
                                <div class="flex items-center justify-between">
                                    <span class="flex items-center font-bold text-gray-800 text-base">
                                        <i data-lucide="${menuIcon}" class="h-6 w-6 ml-3 ${iconColor}"></i>
                                        ${data.name}
                                    </span>
                                    <div class="flex items-center">
                                        ${additionalInfo}
                                        <i data-lucide="chevron-left" class="h-5 w-5 text-gray-400 ml-2"></i>
                                    </div>
                                </div>
                                <p class="text-sm text-gray-500 mt-2 pr-9">${data.desc}</p>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }
        function renderEditScreen(state) {
            backButton.classList.remove('hidden');
            currentEditKey = state.replace('EditScreen_', '');
            const keyData = getFullKeyData(currentEditKey);

            if (!keyData) {
                content.innerHTML = `<p class="text-red-600 p-4 font-bold">خطا: کلید متنی نامعتبر است.</p>`;
                return;
            }

            headerTitle.textContent = `ویرایش: ${keyData.name}`;

            const isNotification = keyData.type === 'USER_NOTIFICATIONS';
            const isUrlField = keyData.isUrl;
            const isBooleanField = keyData.isBoolean;

            // Default text handling improved: Use empty string if no default specified
            const currentText = (appTexts[currentEditKey] ?? keyData.defaultText ?? "").replace(/\\n/g, '\n');

            let markdownGuideHTML = '';
            let inputElement;

            if (isNotification) {
                markdownGuideHTML = `
                    <div class="bg-blue-50 border border-blue-200 p-4 mb-5 rounded-2xl text-sm text-gray-700 shadow-md fade-in-up" style="animation-delay: 50ms;">
                        <p class="font-bold text-blue-700 flex items-center mb-2"><i data-lucide="code" class="h-5 w-5 ml-2"></i> راهنمای Markdown و متغیرها</p>
                        <div class="bg-white border rounded-lg overflow-hidden mt-3">
                            <table class="w-full text-right text-xs">
                                <thead class="bg-gray-100 font-semibold text-gray-600"><tr><th class="p-2 border-b">سینتکس</th><th class="p-2 border-b">توضیح</th><th class="p-2 border-b">نمونه</th></tr></thead>
                                <tbody>
                                    <tr class="hover:bg-gray-50"><td class="p-2 border-b font-mono">**متن**</td><td class="p-2 border-b">بولد</td><td class="p-2 border-b font-bold">متن</td></tr>
                                    <tr class="hover:bg-gray-50"><td class="p-2 border-b font-mono">*متن*</td><td class="p-2 border-b">کج</td><td class="p-2 border-b italic">متن</td></tr>
                                    <tr class="hover:bg-gray-50"><td class="p-2 border-b font-mono">\`کد\`</td><td class="p-2 border-b">کد</td><td class="p-2 border-b font-mono text-sm bg-gray-100 rounded">کد</td></tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="font-bold text-blue-700 mt-4 mb-1 flex items-center"><i data-lucide="variable" class="h-5 w-5 ml-2"></i> متغیرهای پویا</p>
                        <ul class="list-disc pr-5 space-y-1 font-mono text-xs">
                            <li><code>{Subject}</code>: موضوع تیکت</li>
                            <li><code>{Department}</code>: نام دپارتمان</li>
                        </ul>
                    </div>
                `;
            } else {
                 const description = keyData.desc || 'توضیحات خاصی برای این متن موجود نیست.';
                 markdownGuideHTML = `
                       <div class="bg-yellow-50 border border-yellow-200 p-4 mb-5 rounded-2xl text-sm text-gray-700 flex items-start shadow-md fade-in-up" style="animation-delay: 50ms;">
                            <i data-lucide="alert-triangle" class="h-5 w-5 ml-2 text-yellow-700 flex-shrink-0 mt-0.5"></i>
                            <div>
                                 <span class="font-bold text-yellow-700 ml-1">راهنما:</span>
                                 <span>${description}</span>
                            </div>
                       </div>
                     `;
            }

            if (isUrlField) {
                inputElement = `
                    <input id="edit-area" type="url" value="${currentText.replace(/\n/g, '')}" class="w-full p-4 border border-gray-300 rounded-2xl shadow-md focus:border-indigo-500 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 transition duration-150 text-gray-800 text-sm" placeholder="مثلاً: https://yourdomain.com/faq">
                `;
            } else if (isBooleanField) {
                const currentValue = (appTexts[currentEditKey] || "true");
                inputElement = `
                    <select id="edit-area" class="w-full p-4 border border-gray-300 rounded-2xl shadow-md focus:border-indigo-500 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 transition duration-150 text-gray-800 text-sm bg-white">
                        <option value="true" ${currentValue === "true" ? 'selected' : ''}>فعال (نمایش داده شود)</option>
                        <option value="false" ${currentValue === "false" ? 'selected' : ''}>غیرفعال (مخفی شود)</option>
                    </select>
                `;
            } else {
                inputElement = `
                    <textarea id="edit-area" rows="4" class="auto-resize-textarea w-full p-4 border border-gray-300 rounded-2xl shadow-md focus:border-indigo-500 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 transition duration-150 text-gray-800 text-sm" placeholder="متن جدید خود را اینجا وارد کنید...">${currentText}</textarea>
                `;
            }

            content.innerHTML = `
                <h2 class="text-2xl font-extrabold text-gray-800 mb-2 fade-in-up">${keyData.name}</h2>

                ${markdownGuideHTML}

                <!-- [جدید] انیمیشن به ناحیه ویرایش اضافه شد -->
                <div class="fade-in-up" style="animation-delay: 100ms;">
                    ${inputElement}
                </div>

                <div class="flex justify-end space-x-3 mt-6 fade-in-up" style="animation-delay: 150ms;" dir="ltr">
                    <button onclick="handleBack()" class="px-6 py-3 bg-white text-gray-800 rounded-2xl hover:bg-gray-50 transition duration-150 font-semibold shadow-lg btn-press">
                        <i data-lucide="x" class="h-5 w-5 inline ml-1"></i> لغو
                    </button>
                    <button id="save-button" onclick="handleSave()" class="px-6 py-3 bg-indigo-600 text-white rounded-2xl hover:bg-indigo-700 transition duration-150 font-semibold shadow-lg shadow-indigo-400/50 btn-press">
                        <i data-lucide="save" class="h-5 w-5 inline ml-1"></i> ذخیره تغییرات
                    </button>
                </div>
            `;

            const editArea = document.getElementById('edit-area');
            if (editArea && !isUrlField && !isBooleanField) {
                autoResize(editArea);
                editArea.addEventListener('input', () => autoResize(editArea));
            }
        }

        // --- [جدید] توابع رندر نمودار ---

        function initRatingChart() {
            const ctx = document.getElementById('ratingChart');
            // [اصلاح شد] بررسی می‌کند که آیا بوم و داده‌ها قبل از رندر وجود دارند یا خیر
            if (!ctx || !chartData || !chartData.ratings) {
                console.warn('Rating chart canvas or data not ready.');
                return;
            }

            // از بین بردن نمودار قبلی اگر وجود داشت
            if (ratingChartInstance) {
                ratingChartInstance.destroy();
            }

            ratingChartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: chartData.ratings.labels,
                    datasets: [{
                        label: 'تعداد امتیاز',
                        data: chartData.ratings.data,
                        backgroundColor: [
                            '#16a34a', // 5 ستاره (سبز)
                            '#ca8a04', // 4 ستاره (زرد)
                            '#ea580c', // 3 ستاره (نارنجی)
                            '#dc2626', // 2 ستاره (قرمز)
                            '#7f1d1d'  // 1 ستاره (قرمز تیره)
                        ],
                        borderColor: '#ffffff',
                        borderWidth: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                fontFamily: 'Vazirmatn',
                                boxWidth: 12,
                                padding: 15
                            }
                        }
                    }
                }
            });
        }

        function initVolumeChart() {
            const ctx = document.getElementById('volumeChart');
            // [اصلاح شد] بررسی می‌کند که آیا بوم و داده‌ها قبل از رندر وجود دارند یا خیر
            if (!ctx || !chartData || !chartData.volume) {
                 console.warn('Volume chart canvas or data not ready.');
                return;
            }

            if (volumeChartInstance) {
                volumeChartInstance.destroy();
            }

            volumeChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.volume.labels,
                    datasets: [{
                        label: 'تیکت‌های ورودی',
                        data: chartData.volume.data,
                        fill: true,
                        backgroundColor: 'rgba(79, 70, 229, 0.1)', // آبی ملایم
                        borderColor: '#4f46e5', // آبی
                        tension: 0.3, // منحنی نرم
                        pointBackgroundColor: '#4f46e5',
                        pointBorderWidth: 2,
                        pointRadius: 4,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false // مخفی کردن لجند
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: '#f0f2f5' // خطوط گرید کمرنگ
                            },
                            ticks: {
                                stepSize: 1, // گام‌های ۱ واحدی
                                fontFamily: 'Vazirmatn'
                            }
                        },
                        x: {
                            grid: {
                                display: false // حذف گرید عمودی
                            },
                            ticks: {
                                fontFamily: 'Vazirmatn'
                            }
                        }
                    }
                }
            });
        }


        // --- [به‌روزرسانی] تابع اصلی رندر ---

        function render() {
            content.classList.add('transition-all', 'duration-200', 'opacity-0');

            // [اصلاح شد] اطمینان از پاک شدن نمودارهای قبلی
            if (currentState !== 'Dashboard') {
                 if (ratingChartInstance) {
                     ratingChartInstance.destroy();
                     ratingChartInstance = null;
                 }
                if (volumeChartInstance) {
                    volumeChartInstance.destroy();
                    volumeChartInstance = null;
                }
            }

            setTimeout(() => {

                if (currentState === 'Dashboard-Loading') {
                    renderDashboardSkeleton();
                } else if (currentState === 'Dashboard') {
                    renderDashboard();
                } else if (currentState === 'TicketsList') { // [جدید]
                    renderTicketsList();
                } else if (currentState.startsWith('TicketView_')) { // [جدید]
                    renderTicketView(currentState);
                } else if (currentState === 'MainMenu') {
                    renderMainMenu();
                } else if (currentState.startsWith('SubMenu_')) {
                    renderSubMenu_Texts(currentState);
                } else if (currentState.startsWith('EditScreen_')) {
                    renderEditScreen(currentState);
                } else {
                    renderDashboard(); // Fallback
                }

                backButton.classList[history.length > 0 ? 'remove' : 'add']('hidden');
                updateFooterNav(currentState);

                content.classList.remove('opacity-0');

                // [اصلاح شد] فراخوانی createIcons در همه رندرها به جز لودینگ
                if (currentState !== 'Dashboard-Loading') {
                    lucide.createIcons();
                }

            }, 50);
        }

        // رویدادهای اصلی
        backButton.addEventListener('click', handleBack);
        // [جدید] تنظیم ارتفاع خودکار برای فیلد پاسخ
        replyTextarea.addEventListener('input', () => {
            replyTextarea.style.height = 'auto';
            replyTextarea.style.height = (replyTextarea.scrollHeight) + 'px';
        });

        // شروع اپلیکیشن
        fetchInitialData();

        // آیکون‌های اولیه نوار پایین را رندر می‌کند
        lucide.createIcons();
    </script>
</body>
</html>

