<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>مدیریت تیکت تل (Mini App)</title>
    <!-- بارگذاری Tailwind CSS و Lucide Icons -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <!-- [جدید] کتابخانه نمودار Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <!-- [اضافه شده] کتابخانه انتخابگر ایموجی -->
    <script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@^1/index.js"></script>
    <!-- فونت‌های جدید: Vazirmatn برای فارسی و Inter برای انگلیسی -->
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    
    <style>
        /* [اضافه شد] فونت ایموجی گوگل از طریق import@ بارگذاری می‌شود */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Color+Emoji&display=swap');

        body {
            /* [اصلاح شد] فونت ایموجی به انتهای لیست اضافه شد */
            font-family: 'Vazirmatn', 'Inter', 'Noto Color Emoji', Tahoma, sans-serif;
            background-color: #f7f8fa; /* پس‌زمینه خاکستری بسیار روشن */
            padding-bottom: 100px; /* ارتفاع پیش‌فرض نوار ناوبری */
            overflow-x: hidden; /* جلوگیری از اسکرول افقی */
        }
        
        .metric-card {
            background-color: #ffffff;
            padding: 1rem;
            border-radius: 20px; /* گوشه‌های بسیار گرد */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.07);
            border: none;
            transition: all 0.3s;
        }
        .metric-card:hover {
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.1);
            transform: translateY(-3px);
        }
        
        .auto-resize-textarea {
            overflow: hidden; 
            resize: none; 
            min-height: 120px;
            height: auto;
        }

        /* [اضافه شده] استایل برای فیلد پاسخ */
        .reply-textarea-auto {
            overflow-y: hidden; /* جلوگیری از نمایش اسکرول در حالت عادی */
            resize: none; 
            min-height: 48px; /* ارتفاع دکمه ارسال */
            max-height: 150px; /* حداکثر ارتفاع قبل از اسکرول شدن */
        }

        .nav-item.active {
            color: #4f46e5; /* رنگ اصلی اپ (Indigo) */
        }
        .nav-item.active span {
             font-weight: 700;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in-up {
            animation: fadeInUp 0.5s ease-out forwards;
            opacity: 0; 
        }

        @keyframes skeleton-pulse {
            0% { background-color: #f0f2f5; }
            50% { background-color: #e6e8eb; }
            100% { background-color: #f0f2f5; }
        }
        .skeleton-pulse {
            animation: skeleton-pulse 1.5s ease-in-out infinite;
            border-radius: 16px;
        }

        .btn-press {
            transition: transform 0.1s ease;
        }
        .btn-press:active {
            transform: scale(0.96); 
        }

        /* [جدید] استایل برای تب‌های فعال در صفحه تیکت‌ها */
        .ticket-tab.active {
            background-color: #4f46e5;
            color: #ffffff;
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.4);
        }

        /* [جدید] پس‌زمینه رسمی‌تر و تمیزتر */
        .chat-container-bg {
             background-color: #f0f4f7; /* خاکستری بسیار روشن و رسمی */
             min-height: calc(100vh - 160px); 
        }

        /* [جدید] استایل برای حباب‌های چت */
        .chat-bubble {
            padding: 0.35rem 0.75rem; 
            border-radius: 0.75rem; /* 12px (rounded-xl) */
            max-width: 85%; 
            word-wrap: break-word; 
            overflow-wrap: break-word; 
            white-space: pre-wrap; 
            font-size: 0.85rem; /* [کوچک‌سازی] از 0.95rem */
            line-height: 1.5;
        }
        
        /* [جدید] استایل حباب کاربر */
        .chat-bubble.incoming { 
            background-color: #ffffff;
            color: #1f2937;
            box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05); 
            border-bottom-left-radius: 0.375rem; /* 6px (rounded-bl-md) */
        }
        /* [جدید] استایل حباب ادمین */
        .chat-bubble.outgoing { 
            background-color: #2563eb; /* آبی رسمی‌تر (bg-blue-600) */
            color: #ffffff;
            box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
            border-bottom-right-radius: 0.375rem; /* 6px (rounded-br-md) */
        }

        /* [جدید] آواتار */
        .chat-avatar {
            width: 32px; /* [کوچک‌سازی] از 36px */
            height: 32px; /* [کوچک‌سازی] از 36px */
            border-radius: 50%;
            background-color: #a5b4fc; 
            color: #312e81; 
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.75rem; /* [کوچک‌سازی] از 0.8rem */
            flex-shrink: 0; 
        }

        /* [اضافه شده] اعمال فونت ایموجی گوگل به انتخابگر ایموجی */
        emoji-picker {
            font-family: 'Noto Color Emoji', sans-serif;
        }

        /* [اضافه شده] استایل برای انتخابگر ایموجی */
        #emoji-picker {
            position: fixed;
            bottom: 100px; /* موقعیت اولیه، توسط JS تنظیم می‌شود */
            right: 1rem;
            z-index: 30;
            transition: all 0.2s ease-out;
            transform: translateY(20px) scale(0.9);
            opacity: 0;
            pointer-events: none;
        }
        #emoji-picker.visible {
            transform: translateY(0) scale(1);
            opacity: 1;
            pointer-events: auto;
        }

        /* انیمیشن شناور */
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-8px); }
            100% { transform: translateY(0px); }
        }
        .float-animation {
            animation: float 3s ease-in-out infinite;
        }
    </style>
</head>
<body class="antialiased">

    <!-- کانتینر اصلی اپلیکیشن -->
    <div id="app-container">
        <!-- [اصلاح شد] هدر با خط پایین و آیکون با آیدی -->
        <header class="bg-white text-gray-900 p-4 flex items-center border-b border-gray-200 sticky top-0 z-10">
            <!-- [اصلاح شد] آیکون هدر اکنون در سمت راست است (برای RTL) -->
            <button id="back-button" class="text-gray-700 p-2 hover:bg-gray-100 rounded-full transition duration-150 hidden btn-press flex-shrink-0">
                <i id="back-button-icon" data-lucide="chevron-right" class="h-6 w-6"></i>
            </button>
            <!-- [اصلاح شد] عنوان در سمت چپ (برای RTL) و با چینش راست -->
            <h1 id="header-title" class="text-lg font-extrabold mr-4 flex-grow truncate text-right">پنل مدیریت ربات</h1>
        </header>

        <!-- کانتینر اصلی محتوا (padding و space-y کاهش یافت) -->
        <div id="content" class="p-4 space-y-4">
            <!-- لودر اولیه در اینجا قرار می‌گیرد -->
            <div id="loading-spinner" class="text-center p-8 mt-10">
                 <!-- این محتوا توسط render() یا renderDashboardSkeleton() جایگزین خواهد شد -->
            </div>
        </div>

        <!-- [اصلاح شد] فیلد ارسال پاسخ: bottom-20 به bottom-0 تغییر کرد -->
        <div id="reply-container" class="fixed bottom-0 left-0 right-0 bg-gray-50 border-t border-gray-200 p-4 shadow-[0_-5px_20px_rgba(0,0,0,0.05)] z-20 transform translate-y-full transition-transform duration-300">
            <div class="flex items-end space-x-3" dir="ltr">
                <button id="send-reply-btn" class="bg-indigo-600 text-white p-3 h-12 w-12 rounded-full btn-press shadow-lg shadow-indigo-300 flex-shrink-0">
                    <i data-lucide="send" class="h-6 w-6"></i>
                </button>
                <textarea id="reply-textarea" rows="1" class="reply-textarea-auto flex-grow p-3 bg-gray-200 focus:bg-white rounded-2xl border border-transparent focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 transition duration-150 text-gray-800 text-xs" placeholder="پاسخ خود را بنویسید..."></textarea> <!-- [کوچک‌سازی] text-sm به text-xs -->
                <!-- دکمه پاسخ‌های آماده -->
                <button id="canned-reply-btn" class="p-3 h-12 w-12 rounded-full text-gray-500 hover:bg-gray-200 transition-colors btn-press flex-shrink-0">
                    <i data-lucide="zap" class="h-6 w-6"></i>
                </button>
                <!-- دکمه ایموجی -->
                <button id="emoji-btn" class="p-3 h-12 w-12 rounded-full text-gray-500 hover:bg-gray-200 transition-colors btn-press flex-shrink-0">
                    <i data-lucide="smile" class="h-6 w-6"></i>
                </button>
            </div>
        </div>

    </div>

    <!-- [اصلاح شد] کانتینر انتخابگر ایموجی اکنون data-source را مستقیماً در HTML دارد -->
    <emoji-picker 
        id="emoji-picker" 
        class="light"
        data-source="https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/fa/emojibase/data.json"
    ></emoji-picker>

    <!-- [جدید] نوار ناوبری پایین صفحه - سه‌بخشی -->
    <nav id="footer-nav" class="fixed bottom-0 left-0 right-0 bg-white shadow-[0_-5px_20px_rgba(0,0,0,0.05)] rounded-t-3xl h-20 flex justify-around items-center z-10">
        <button onclick="navigateTo('Dashboard', getDashboardTitle(STORE_HANDLE || MOCK_STORE_HANDLE))" id="nav-dashboard" class="nav-item btn-press flex flex-col items-center justify-center text-gray-500 w-1/3" data-page="Dashboard">
            <!-- [اصلاح شد] آیکون داشبورد به حالت فایل جدید برگشت -->
            <i data-lucide="layout-dashboard" class="h-6 w-6"></i>
            <span class="text-xs font-semibold mt-1">داشبورد</span>
        </button>
        <button onclick="navigateTo('TicketsList', 'لیست تیکت‌ها')" id="nav-tickets" class="nav-item btn-press flex flex-col items-center justify-center text-gray-500 w-1/3" data-page="TicketsList">
            <i data-lucide="inbox" class="h-6 w-6"></i>
            <span class="text-xs font-semibold mt-1">تیکت‌ها</span>
        </button>
        <button onclick="navigateTo('MainMenu', 'مدیریت متون')" id="nav-settings" class="nav-item btn-press flex flex-col items-center justify-center text-gray-500 w-1/3" data-page="MainMenu">
            <i data-lucide="settings" class="h-6 w-6"></i>
            <span class="text-xs font-semibold mt-1">تنظیمات</span>
        </button>
    </nav>


    <!-- پیام نمایش داده شده در پایین صفحه -->
    <div id="message-box" class="fixed bottom-24 left-4 right-4 p-4 text-white text-center rounded-2xl shadow-2xl z-20 hidden transform transition-all duration-300 translate-y-10 opacity-0">
        عملیات با موفقیت انجام شد!
    </div>

    <script>
        // --- تنظیمات مهم (WORKER & STORE) ---
        // ... (کد قبلی) ...
        const urlParams = new URLSearchParams(window.location.search);
        const STORE_HANDLE = urlParams.get('storeHandle');
        const MOCK_STORE_HANDLE = 'test-store-mock-dfdfdfd';

        // [جدید] اضافه کردن departmentMap در اینجا
        const departmentMap = {
            general: 'سوالات متفرقه',
            technical: 'پشتیبانی فنی',
            sales: 'بخش فروش',
            marketing: 'بازاریابی',
            ideas: 'ایده ها و پیشنهادات',
        };
        // [جدید] اضافه کردن statusMap در اینجا (برای استفاده احتمالی در آینده)
        const statusMap = {
            open: 'باز (در حال بررسی)',
            closed: 'بسته شده',
            pending_user_reply: 'در انتظار پاسخ شما',
        };


        // --- MOCK DATA ---
        const mockAppTexts = {
            greetingTitle: "سلام مدیر عزیز! 👋 (آزمایشی)",
            quickTipMessage: "💡 نکته: این متون برای تست در حالت آزمایشی بارگذاری شده‌اند.",
            faqButtonEnabled: "true",
            faqButtonText: "مشاهده سوالات متداول",
            faqUrl: "https://mock.faq.com/",
            navTickets: "تیکت‌ها",
            navNewTicket: "تیکت جدید",
            infoModalTitle: "راهنمای ارسال تیکت",
            infoModalTip: "لطفا ابتدا صفحه سوالات متداول را بررسی کنید.",
            closedTicketBanner: "این گفتگو توسط پشتیبانی بسته شده است.",
            submitNewTicketBtn: "ارسال",
            modalCloseBtn: "متوجه شدم",
            userReplyNotification: "✅ *پشتیبانی فنی* به تیکت شما با موضوع *مشکل اتصال* پاسخ داد.\\n\\nبرای مشاهده پاسخ کلیک کنید.",
            ticketClosedNotification: "🎫 تیکت شما با موضوع *پرداخت ناموفق* بسته شد.\\n\\nلطفا امتیاز دهید.",
        };
        const mockAppStats = {
            totalCount: '145',
            totalActive: '4',
            openCount: '3',
            pendingCount: '1',
            avgRating: '4.92',
            ratingPercentage: '88.5',
            ratedTicketsCount: 120,
            avgFirstResponseTime: '3 ساعت و 15 دقیقه',
            avgTimeToResolution: '1 روز و 5 ساعت',
        };

        // [جدید] داده‌های آزمایشی برای لیست تیکت‌ها
        const mockAppTickets = [
            { id: 'T1001', subject: 'مشکل در اتصال به سرور', user_name: 'کاربر ۱۲۳', status: 'open', department: 'technical', created_at: new Date(Date.now() - 5 * 60 * 1000).toISOString(), messages: [ // استفاده از user_name و technical
                { sender: 'user', text: 'سلام، من نمی‌توانم به سرور متصل شوم.', created_at: new Date(Date.now() - 5 * 60 * 1000).toISOString() },
                { sender: 'admin', text: 'سلام، لطفاً لحظاتی صبر کنید تا بررسی کنیم.', created_at: new Date(Date.now() - 4 * 60 * 1000).toISOString() },
                { sender: 'user', text: 'هنوز منتظرم. لطفاً سریع‌تر.', created_at: new Date(Date.now() - 3 * 60 * 1000).toISOString() }, // \n حذف شد
                { sender: 'admin', text: 'در حال بررسی هستیم. این مشکل سراسری به نظر می‌رسد.', created_at: new Date(Date.now() - 2 * 60 * 1000).toISOString() },
            ]},
            { id: 'T1002', subject: 'سوال در مورد تعرفه', user_name: 'کاربر ۴۵۶', status: 'open', department: 'sales', created_at: new Date(Date.now() - 60 * 60 * 1000).toISOString(), messages: [ // استفاده از user_name و sales
                { sender: 'user', text: 'سلام، تعرفه پلن حرفه‌ای چقدر است؟', created_at: new Date(Date.now() - 60 * 60 * 1000).toISOString() },
            ]},
            { id: 'T1003', subject: 'گزارش باگ', user_name: 'کاربر ۷۸۹', status: 'closed', department: 'technical', created_at: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(), messages: [ // استفاده از user_name و technical
                { sender: 'user', text: 'دکمه خروج کار نمی‌کند.', created_at: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString() },
                { sender: 'admin', text: 'ممنون از گزارش شما، در نسخه بعدی رفع خواهد شد. تیکت بسته شد.', created_at: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString() },
            ]},
        ];

        // [جدید] داده‌های آزمایشی برای نمودارها
        const mockChartData = {
            ratings: {
                labels: ['۵ ستاره', '۴ ستاره', '۳ ستاره', '۲ ستاره', '۱ ستاره'],
                data: [100, 15, 3, 1, 1], // 120 امتیاز
            },
            volume: {
                labels: ['شنبه', '۱شنبه', '۲شنبه', '۳شنبه', '۴شنبه', '۵شنبه', 'جمعه'],
                data: [5, 8, 3, 12, 10, 15, 7],
            }
        };

        const WORKER_API_BASE_URL = 'https://ticketing.amiruserbot7.workers.dev';
        const getDashboardTitle = (handle) => `داشبورد (${handle || 'ناشناس'})`;

        // --- پایان تنظیمات ---

        const content = document.getElementById('content');
        const backButton = document.getElementById('back-button');
        const headerTitle = document.getElementById('header-title');
        const messageBox = document.getElementById('message-box');
        // [اضافه شده] متغیرهای کادر پاسخ
        const replyContainer = document.getElementById('reply-container');
        const replyTextarea = document.getElementById('reply-textarea');
        const sendReplyBtn = document.getElementById('send-reply-btn'); 
        // [اصلاح شد] emojiPicker در تابع setupEmojiPicker تعریف خواهد شد
        // const emojiPicker = document.getElementById('emoji-picker'); 

        let currentState = 'Dashboard-Loading';
        const history = [];
        let appTexts = {};
        let appStats = {};
        let appTickets = []; // [جدید] اکنون به درستی یک آرایه خواهد بود
        let chartData = {};  // [جدید]
        let currentTicketListFilter = 'open'; // [جدید]
        let currentTicketId = null; // [جدید]
        let currentEditKey = null;
        let successMessage = null;

        // [جدید] متغیرهای چارت‌ها برای جلوگیری از رندر تکراری
        let ratingChartInstance = null;
        let volumeChartInstance = null;

        const CUSTOM_TEXT_KEYS = {
            MINI_APP_UI: {
                greetingTitle: { name: "عنوان خوش‌آمدگویی", icon: "user-check", desc: `متن اصلی کارت راهنما (مثلاً: سلام مشتری عزیز!)` },
                quickTipMessage: { name: "پیام راهنمای سریع", icon: "lightbulb", desc: `متن کوچک زیر عنوان در کارت راهنما (مثلاً: لطفا مشکل را با جزئیات بنویسید)` },
                faqButtonEnabled: { name: "وضعیت دکمه راهنما", icon: "toggle-right", desc: `دکمه سوالات متداول را در مینی‌اپ فعال یا غیرفعال کنید.`, isBoolean: true },
                faqButtonText: { name: "متن دکمه راهنما", icon: "help-circle", desc: `متنی که روی دکمه مشاهده سوالات متداول نمایش داده می‌شود.` },
                faqUrl: { name: "لینک دکمه راهنما", icon: "link", desc: `آدرس URL کامل (باید با https:// شروع شود).`, isUrl: true },
                navTickets: { name: "منوی: تیکت‌ها", icon: "ticket", desc: `متن آیکون تیکت‌ها در نوار پایین مینی‌اپ.` },
                navNewTicket: { name: "منوی: تیکت جدید", icon: "file-plus", desc: `متن آیکون ایجاد تیکت جدید در نوار پایین مینی‌اپ.` },
                infoModalTitle: { name: "عنوان راهنمای تیکت", icon: "info", desc: `عنوان پنجره‌ای که قبل از ثبت تیکت جدید نمایش داده می‌شود.` },
                infoModalTip: { name: "پیام راهنمای مودال", icon: "message-square-text", desc: `متن اصلی داخل پنجره راهنما قبل از ثبت تیکت.` },
                closedTicketBanner: { name: "بنر تیکت بسته شده", icon: "lock", desc: `متنی که در پایین یک تیکت بسته شده نمایش داده می‌شود.` },
                submitNewTicketBtn: { name: "متن دکمه ارسال", icon: "send", desc: `متنی که روی دکمه 'ارسال' تیکت جدید نمایش داده می‌شود.` },
                modalCloseBtn: { name: "متن دکمه متوجه شدم", icon: "x-circle", desc: `متن دکمه بستن پنجره‌های مودال.` },
            },
            USER_NOTIFICATIONS: {
                userReplyNotification: { name: "اعلان پاسخ ادمین", icon: "bell-plus", desc: `متنی که پس از پاسخ ادمین، برای کاربر ارسال می‌شود. این متن از متغیرهای پویا پشتیبانی می‌کند.` },
                ticketClosedNotification: { name: "اعلان بسته شدن تیکت", icon: "bell-off", desc: `متنی که پس از بستن تیکت، برای کاربر ارسال می‌شود. این متن از متغیرهای پویا پشتیبانی می‌کند.` },
            }
        };

        // --- توابع کمکی ---

        // [اضافه شده] تابع درج متن ایموجی
        function insertTextAtCursor(field, text) {
            let startPos = field.selectionStart;
            let endPos = field.selectionEnd;
            let _val = field.value;
            field.value = _val.substring(0, startPos) + text + _val.substring(endPos, _val.length);
            field.selectionStart = startPos + text.length;
            field.selectionEnd = startPos + text.length;
            field.focus();
            autoResize(field); // تغییر اندازه خودکار پس از درج ایموجی
        }

        // [اصلاح شده] تابع تغییر اندازه خودکار (بخش مربوط به کادر پاسخ اضافه شد)
        function autoResize(el) {
            if (el.classList.contains('reply-textarea-auto')) {
                el.style.height = 'auto'; 
                let newHeight = el.scrollHeight;
                const maxHeight = 150; 
                
                if (newHeight > maxHeight) {
                    el.style.height = maxHeight + 'px';
                    el.style.overflowY = 'auto'; 
                } else {
                    el.style.height = (newHeight < 48 ? 48 : newHeight) + 'px'; // حداقل ارتفاع 48px
                    el.style.overflowY = 'hidden'; 
                }
            } else if (el.classList.contains('auto-resize-textarea')) { // سازگاری با صفحه ویرایش
                 el.style.height = 'auto';
                 el.style.height = (el.scrollHeight) + 'px';
            }
        }


        function getFullKeyData(key) {
            for (const menuType in CUSTOM_TEXT_KEYS) {
                if (CUSTOM_TEXT_KEYS[menuType][key]) {
                    return { type: menuType, key, ...CUSTOM_TEXT_KEYS[menuType][key] };
                }
            }
            return null;
        }
        function showMessage(text, type = 'success', duration = 4000) {
            let bgColor = 'bg-green-600';
            if (type === 'error') bgColor = 'bg-red-600';
            if (type === 'info') bgColor = 'bg-blue-600';

            messageBox.textContent = text;
            messageBox.className = `fixed bottom-24 left-4 right-4 p-4 text-white text-center rounded-2xl shadow-2xl z-20 transform transition-all duration-300 ${bgColor}`;

            setTimeout(() => {
                messageBox.classList.remove('hidden', 'translate-y-10', 'opacity-0');
            }, 10);

            setTimeout(() => {
                messageBox.classList.add('translate-y-10', 'opacity-0');
                setTimeout(() => messageBox.classList.add('hidden'), 300);
            }, duration);
        }

        // [اصلاح شد] تابع نمایش یا پنهان کردن فیلد پاسخ
        function showReplyContainer(show) {
            const bodyPaddingBottomNav = '100px'; // ارتفاع نوار ناوبری 80px + 20px فضای خالی
            const footerNav = document.getElementById('footer-nav'); // [جدید] نوار ناوبری را پیدا کن
            const emojiPicker = document.getElementById('emoji-picker'); // [جدید] انتخابگر ایموجی را پیدا کن
            
             if (show) {
                replyContainer.classList.remove('translate-y-full'); // کادر پاسخ را نشان بده
                if (footerNav) footerNav.classList.add('hidden'); // [جدید] نوار ناوبری را مخفی کن
                
                // محاسبه ارتفاع و پدینگ بر اساس ارتفاع کادر پاسخ
                const replyHeight = replyContainer.offsetHeight || 72; // ارتفاع پیش‌فرض 72px
                const totalPadding = replyHeight + 16; // 16px (فاصله)
                document.body.style.paddingBottom = `${totalPadding}px`;
                // [اصلاح شد] موقعیت ایموجی بر اساس ارتفاع کادر پاسخ
                if (emojiPicker) emojiPicker.style.bottom = `${replyHeight + 16}px`; 
                
                // اسکرول به پایین با یک تاخیر کوتاه برای رندر
                setTimeout(() => window.scrollTo(0, document.body.scrollHeight), 50); 
            } else {
                replyContainer.classList.add('translate-y-full'); // کادر پاسخ را مخفی کن
                if (footerNav) footerNav.classList.remove('hidden'); // [جدید] نوار ناوبری را نشان بده
                document.body.style.paddingBottom = bodyPaddingBottomNav; 
                if (emojiPicker) emojiPicker.classList.remove('visible'); // مخفی کردن ایموجی
            }
        }


        // [به‌روزرسانی] تابع به‌روزرسانی نوار ناوبری پایین
        function updateFooterNav(state) {
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active', 'text-indigo-600');
                item.classList.add('text-gray-500');
            });

            let activeItem;
            if (state === 'Dashboard' || state === 'Dashboard-Loading') {
                activeItem = document.getElementById('nav-dashboard');
            } else if (state === 'TicketsList' || state.startsWith('TicketView_')) { // [جدید]
                activeItem = document.getElementById('nav-tickets');
            } else if (state === 'MainMenu' || state.startsWith('SubMenu_') || state.startsWith('EditScreen_')) {
                activeItem = document.getElementById('nav-settings');
            }

            if (activeItem) {
                activeItem.classList.add('active', 'text-indigo-600');
                activeItem.classList.remove('text-gray-500');
            }
        }

        // [اصلاح شده] تابع ناوبری (منطق کادر پاسخ اضافه شد)
        function navigateTo(newState, title = null, pushHistory = true) {
            if (pushHistory && currentState !== 'Dashboard-Loading') {
                history.push(currentState);
            }
            currentState = newState;
            currentTicketId = null; // ریست کردن آیدی تیکت

            const currentHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            const dashboardTitle = getDashboardTitle(currentHandle);
            const backButtonIcon = document.getElementById('back-button-icon');

            headerTitle.textContent = title || dashboardTitle;
            updateFooterNav(newState);

            // [اصلاح شده] منطق نمایش/پنهان کردن کادر پاسخ اضافه شد
            if (currentState.startsWith('TicketView_')) {
                showReplyContainer(true);
                if (backButtonIcon) backButtonIcon.setAttribute('data-lucide', 'x');
                // [جدید] تنظیم آیدی تیکت فعلی
                currentTicketId = currentState.replace('TicketView_', '');
            } else {
                showReplyContainer(false);
                if (backButtonIcon) backButtonIcon.setAttribute('data-lucide', 'chevron-right');
            }

            render();
            window.scrollTo(0, 0);
        }

        // [اصلاح شده] تابع بازگشت (منطق کادر پاسخ اضافه شد)
        function handleBack() {
            const backButtonIcon = document.getElementById('back-button-icon');
            
            if (currentState.startsWith('EditScreen_')) {
                currentEditKey = null;
            }
            // [اضافه شده] منطق پنهان کردن فیلد پاسخ
            if (currentState.startsWith('TicketView_')) {
                 showReplyContainer(false);
                 currentTicketId = null; // ریست کردن آیدی
                 const emojiPicker = document.getElementById('emoji-picker');
                 if (emojiPicker) emojiPicker.classList.remove('visible'); // [جدید] مخفی کردن ایموجی
            }

            if (history.length > 0) {
                const previousState = history.pop();

                const currentHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
                const dashboardTitle = getDashboardTitle(currentHandle);

                let title = dashboardTitle;
                if (previousState === 'MainMenu') title = 'مدیریت متون';
                if (previousState === 'TicketsList') title = 'لیست تیکت‌ها'; // [جدید]
                if (previousState.startsWith('SubMenu_')) {
                    const menuType = previousState.replace('SubMenu_', '');
                    title = menuType === 'MINI_APP_UI' ? 'متن‌های مینی‌اپ' : 'متن‌های اعلان ربات';
                }

                currentState = previousState;
                headerTitle.textContent = title;
                updateFooterNav(previousState);
                
                // [جدید] تنظیم آیکون بازگشت به حالت پیش‌فرض
                if (backButtonIcon) backButtonIcon.setAttribute('data-lucide', 'chevron-right');
                
                render(false);
                window.scrollTo(0, 0);
            } else {
                navigateTo('Dashboard', getDashboardTitle(STORE_HANDLE || MOCK_STORE_HANDLE), false);
            }
        }

        // --- Data Fetching (از Worker API) ---
        async function fetchStats() {
            const currentStoreHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            if (currentStoreHandle === MOCK_STORE_HANDLE) return mockAppStats;

            const url = `${WORKER_API_BASE_URL}/api/${currentStoreHandle}/stats`;
            const response = await fetch(url);
            if (!response.ok) throw new Error('Failed to fetch stats from Worker.');
            const result = await response.json();
            if (!result.success) throw new Error(result.error || 'Worker stats returned error.');
            return result.data;
        }
        async function fetchAppTexts() {
            const currentStoreHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            if (currentStoreHandle === MOCK_STORE_HANDLE) return mockAppTexts;

            const url = `${WORKER_API_BASE_URL}/api/${currentStoreHandle}/texts`;
            const response = await fetch(url);
            if (!response.ok) throw new Error('Worker failed to fetch texts.');
            const result = await response.json();
            if (!result.success) throw new Error(result.error || 'Worker texts returned error.');
            return result.data;
        }

        // [اصلاح شد] تابع واکشی تیکت‌ها برای تبدیل آبجکت به آرایه
        async function fetchTickets() {
            const currentStoreHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            if (currentStoreHandle === MOCK_STORE_HANDLE) {
                 console.log("Fetching mock tickets");
                 return mockAppTickets; // داده mock از قبل آرایه است
            }

            const url = `${WORKER_API_BASE_URL}/api/${currentStoreHandle}/tickets`;
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to fetch tickets from Worker (${response.status})`);
                const result = await response.json();
                if (!result.success) throw new Error(result.error || 'Worker tickets returned error.');

                // -----------------------------------------------------------------
                // [اصلاح حیاتی] تبدیل آبجکت به آرایه
                // -----------------------------------------------------------------
                const ticketsObject = result.data || {};
                const ticketsArray = Object.keys(ticketsObject).map(key => {
                    // آبجکت تیکت را با 'id' که همان کلید فایربیس است، ترکیب می‌کنیم
                    return {
                        id: key,
                        ...ticketsObject[key]
                    };
                });

                console.log("Fetched and converted tickets:", ticketsArray); // برای دیباگ
                return ticketsArray; // بازگشت آرایه اصلاح شده
                // -----------------------------------------------------------------

            } catch (error) {
                console.error("Error fetching real tickets:", error.message);
                showMessage(`❌ خطا در واکشی لیست تیکت‌ها: ${error.message}.`, 'error');
                return []; // بازگشت آرایه خالی در صورت خطا
            }
        }

        // [جدید] تابع واکشی داده‌های نمودار
        async function fetchChartData() {
            // [اصلاح شد] اکنون داده‌های واقعی را واکشی می‌کند
            const currentStoreHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
             if (currentStoreHandle === MOCK_STORE_HANDLE) {
                 console.log("Fetching mock chart data");
                 return mockChartData;
             }

            const url = `${WORKER_API_BASE_URL}/api/${currentStoreHandle}/chartdata`; // فرض بر این است که این endpoint داده‌های نمودار است
             try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to fetch chart data from Worker.');
                const result = await response.json();
                if (!result.success) throw new Error(result.error || 'Worker chart data returned error.');
                // اطمینان از اینکه ساختار داده با داده‌های آزمایشی مطابقت دارد
                return {
                    ratings: result.data.ratings || { labels: [], data: [] },
                    volume: result.data.volume || { labels: [], data: [] }
                };
            } catch (error) {
                console.error("Error fetching real chart data:", error.message);
                showMessage(`❌ خطا در واکشی داده‌های نمودار: ${error.message}.`, 'error');
                // بازگشت ساختار خالی در صورت خطا
                return {
                    ratings: { labels: [], data: [] },
                    volume: { labels: [], data: [] }
                };
            }
        }


        // [به‌روزرسانی] تابع واکشی داده‌های اولیه
        async function fetchInitialData() {
            currentState = 'Dashboard-Loading';
            render();

            try {
                // [اصلاح شد] دیگر در صورت نبودن STORE_HANDLE خطا نمی‌دهد، فقط به حالت آزمایشی می‌رود
                const isMockMode = !STORE_HANDLE;

                if (isMockMode) {
                    console.warn("Missing STORE_HANDLE, loading mock data.");
                    appTexts = mockAppTexts;
                    appStats = mockAppStats;
                    appTickets = mockAppTickets;
                    chartData = mockChartData;
                } else {
                     // [جدید] واکشی تمام داده‌ها به صورت موازی
                    const [textsData, statsData, ticketsData, chartApiData] = await Promise.all([
                        fetchAppTexts(),
                        fetchStats(),
                        fetchTickets(), // این تابع اکنون آرایه برمی‌گرداند
                        fetchChartData()
                    ]);

                    appTexts = textsData;
                    appStats = statsData;
                    appTickets = ticketsData; // اکنون ticketsData یک آرایه است
                    chartData = chartApiData;
                }

            } catch (error) {
                console.error(`Error in fetchInitialData: ${error.message}. Loading mock data as fallback...`);
                appTexts = mockAppTexts;
                appStats = mockAppStats;
                appTickets = mockAppTickets;
                chartData = mockChartData;
                showMessage(`❌ خطا در اتصال به API: ${error.message.substring(0, 50)}... بارگذاری داده آزمایشی.`, 'error');
            }

            // [اصلاح شد] داده‌های آزمایشی اکنون به درستی کپی عمیق می‌شوند
            if (!STORE_HANDLE) {
                 appTickets = JSON.parse(JSON.stringify(mockAppTickets));
            }

            // [اصلاح شد] به جای رندر مستقیم، به داشبورد ناوبری می‌کنیم
            // این تضمین می‌کند که منطق showReplyContainer(false) به درستی اجرا می‌شود
            const currentHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            // false به این معنی است که این مورد را به تاریخچه اضافه نکن
            navigateTo('Dashboard', getDashboardTitle(currentHandle), false); 
        }

        // --- Data Persistence (از طریق Worker API) ---
        async function handleSave() {
            const saveButton = document.getElementById('save-button');
            const editElement = document.getElementById('edit-area');
            const newText = editElement.value;

            if (!currentEditKey) return;
            const keyData = getFullKeyData(currentEditKey);

            if (keyData.isUrl) {
                if (!newText.startsWith('https://')) {
                    showMessage('❌ لینک باید با https:// شروع شود.', 'error', 5000);
                    return;
                }
            }

            saveButton.disabled = true;
            saveButton.innerHTML = '<i data-lucide="loader-circle" class="animate-spin h-5 w-5 inline mr-2"></i> در حال ذخیره...';
            lucide.createIcons();

            const currentStoreHandle = STORE_HANDLE || MOCK_STORE_HANDLE;

            if (currentStoreHandle === MOCK_STORE_HANDLE) {
                appTexts[currentEditKey] = newText;
                successMessage = `✅ تنظیم "${keyData.name}" با موفقیت در حالت آزمایشی ذخیره شد!`;

                navigateTo(`SubMenu_${keyData.type}`, 'مدیریت متون');
                return;
            }

            const url = `${WORKER_API_BASE_URL}/api/${currentStoreHandle}/texts`;
            const payload = { [currentEditKey]: newText };

            try {
                const response = await fetch(url, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    appTexts[currentEditKey] = newText;
                    successMessage = `✅ تنظیم "${keyData.name}" با موفقیت ذخیره و اعمال شد!`;

                    navigateTo(`SubMenu_${keyData.type}`, 'مدیریت متون');
                } else {
                    throw new Error(result.error || 'خطا در Worker API هنگام ذخیره.');
                }
            } catch (error) {
                console.error("Error saving text via Worker:", error);
                showMessage(`❌ خطا در ذخیره تنظیم: ${error.message}`, 'error');
            } finally {
                saveButton.disabled = false;
                saveButton.innerHTML = '<i data-lucide="save" class="h-5 w-5 inline ml-1"></i> ذخیره تغییرات';
                lucide.createIcons();
            }
        }

        // [اضافه شده] تابع ارسال پاسخ به ورکر
        async function sendAdminReplyToWorker(ticketId, text) {
            console.log(`Sending Reply: Ticket ${ticketId}, Text: ${text}`);
            
            sendReplyBtn.disabled = true;
            sendReplyBtn.innerHTML = '<i data-lucide="loader-circle" class="animate-spin h-6 w-6"></i>';
            lucide.createIcons();

            const currentStoreHandle = STORE_HANDLE || MOCK_STORE_HANDLE;

            // --- حالت آزمایشی ---
            if (currentStoreHandle === MOCK_STORE_HANDLE) {
                await new Promise(resolve => setTimeout(resolve, 700)); // شبیه‌سازی تاخیر شبکه
                const ticket = appTickets.find(t => t.id === ticketId);
                if (ticket) {
                    if (!ticket.messages) ticket.messages = [];
                    ticket.messages.push({
                        sender: 'admin',
                        text: text,
                        created_at: new Date().toISOString()
                    });
                }
                
                replyTextarea.value = '';
                autoResize(replyTextarea); 
                
                fetchMessagesForTicket(ticketId, ticket); // رفرش چت
                
                showMessage('✅ (آزمایشی) پاسخ شما ثبت شد.');
            } else {
                // --- حالت واقعی (API) ---
                const url = `${WORKER_API_BASE_URL}/api/${currentStoreHandle}/messages`;
                const payload = {
                    ticket_id: ticketId,
                    sender: 'admin',
                    text: text,
                    source: 'admin-mini-app' 
                };

                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const result = await response.json();
                    
                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'خطا در ارسال پیام');
                    }
                    
                    // موفقیت
                    replyTextarea.value = '';
                    autoResize(replyTextarea); 
                    
                    // رفرش کردن پیام‌ها (در حالت واقعی، ورکر باید پیام جدید را اضافه کند، ما فقط واکشی می‌کنیم)
                    const ticket = appTickets.find(t => t.id === ticketId);
                    await fetchMessagesForTicket(ticketId, ticket); // رفرش چت
                    
                    showMessage('✅ پاسخ شما با موفقیت ارسال شد.');

                } catch (error) {
                    console.error("Error sending admin reply:", error);
                    showMessage(`❌ خطا در ارسال پاسخ: ${error.message}`, 'error');
                }
            }

            // بازگرداندن دکمه به حالت اولیه
            sendReplyBtn.disabled = false;
            sendReplyBtn.innerHTML = '<i data-lucide="send" class="h-6 w-6"></i>';
            lucide.createIcons();
        }

        // =================================================================
        // RENDER FUNCTIONS (UI) - بازطراحی شده
        // =================================================================

        // [به‌روزرسانی] تابع رندر لودر اسکلتی
        function renderDashboardSkeleton() {
            backButton.classList.add('hidden');
            const currentHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            headerTitle.textContent = getDashboardTitle(currentHandle);

            content.innerHTML = `
                <div class="space-y-4 animate-pulse">
                    <h2 class="text-xl font-extrabold text-gray-800 border-b pb-2 mb-3">گزارش عملکرد</h2> <!-- [کوچک‌سازی] 2xl به xl -->

                    <!-- Skeleton for Metric Cards -->
                    <div class="grid grid-cols-2 gap-3">
                        <div class="skeleton-pulse h-24"></div>
                        <div class="skeleton-pulse h-24"></div>
                        <div class="skeleton-pulse h-24"></div>
                        <div class="skeleton-pulse h-24"></div>
                    </div>

                    <!-- [جدید] Skeleton for KPI Card (بزرگتر برای نمودارها) -->
                    <div class="skeleton-pulse w-full h-80"></div>

                    <!-- Skeleton for Button -->
                    <div class="skeleton-pulse w-full h-16 mt-3"></div>
                </div>
            `;
        }


        // [به‌روزرسانی] تابع رندر داشبورد
        function renderDashboard() {
            backButton.classList.add('hidden');
            const currentHandle = STORE_HANDLE || MOCK_STORE_HANDLE;
            headerTitle.textContent = getDashboardTitle(currentHandle);
            const stats = appStats;

            // ... (کد قبلی پیام موفقیت و progressBarColor) ...
            if (successMessage) {
                showMessage(successMessage);
                successMessage = null;
            }
            const ratingPercent = parseFloat(stats.ratingPercentage || '0');
            const progressBarColor = ratingPercent >= 90 ? 'bg-green-500' :
                                       ratingPercent >= 75 ? 'bg-yellow-500' : 'bg-red-500';


            const metricCards = [
                { title: "کل تیکت‌ها", value: stats.totalCount || '0', icon: "ticket", color: "text-indigo-600", desc: "تعداد کل تیکت‌های ثبت شده." },
                { title: "تیکت‌های فعال", value: stats.totalActive || '0', icon: "inbox", color: "text-red-600", desc: "باز و در انتظار پاسخ ادمین." },
                { title: "امتیاز میانگین", value: `${stats.avgRating || 'N/A'} / 5.00`, icon: "star", color: "text-yellow-600", desc: `بر اساس ${stats.ratedTicketsCount || 0} امتیاز.` },
                { title: "میانگین پاسخ", value: stats.avgFirstResponseTime || 'N/A', icon: "clock-3", color: "text-green-600", desc: "زمان متوسط اولین پاسخ." },
            ];

            content.innerHTML = `
                <div class="space-y-4">

                    <h2 class="text-xl font-extrabold text-gray-800 border-b pb-2 mb-3 fade-in-up" style="animation-delay: 100ms;">گزارش عملکرد</h2> <!-- [کوچک‌سازی] 2xl به xl -->

                    <div class="grid grid-cols-2 gap-3">
                        ${metricCards.map((card, index) => `
                            <div class="metric-card fade-in-up" style="animation-delay: ${150 + index * 50}ms;">
                                <div class="flex items-center justify-between mb-3">
                                    <h3 class="text-xs font-semibold text-gray-500">${card.title}</h3> <!-- [کوچک‌سازی] sm به xs -->
                                    <i data-lucide="${card.icon}" class="${card.color} h-6 w-6"></i>
                                </div>
                                <p class="text-xl font-extrabold text-gray-900">${card.value}</p> <!-- [کوچک‌سازی] 2xl به xl -->
                                <p class="text-xs text-gray-400 mt-1 truncate">${card.desc}</p>
                            </div>
                        `).join('')}
                    </div>

                    <!-- [جدید] کارت KPI و نمودارها -->
                    <div class="metric-card bg-white fade-in-up" style="animation-delay: 350ms;">
                        <h3 class="text-base font-bold text-gray-800 mb-3 flex items-center"> <!-- [کوچک‌سازی] lg به base -->
                            <i data-lucide="zap" class="h-5 w-5 ml-2 text-purple-600"></i> شاخص‌های کلیدی (KPI)
                        </h3>
                        <div class="space-y-3">
                            <p class="flex justify-between text-xs"> <!-- [کوچک‌سازی] sm به xs -->
                                <span class="text-gray-600">زمان حل نهایی تیکت:</span>
                                <span class="font-bold text-gray-800">${stats.avgTimeToResolution || 'N/A'}</span>
                            </p>
                            <div>
                                <p class="flex justify-between text-xs mb-1"> <!-- [کوچک‌سازی] sm به xs -->
                                    <span class="text-gray-600">درصد رضایت کاربران:</span>
                                    <span class="font-bold text-gray-800">${stats.ratingPercentage || '0.0'}%</span>
                                </p>
                                <div class="w-full bg-gray-200 rounded-full h-2.5 overflow-hidden">
                                    <div class="${progressBarColor} h-2.5 rounded-full transition-all duration-500" style="width: ${ratingPercent > 100 ? 100 : ratingPercent}%;"></div>
                                </div>
                            </div>
                        </div>

                        <!-- [جدید] بخش نمودارها -->
                        <div class="mt-6 border-t pt-4">
                            <!-- نمودار دایره‌ای -->
                            <h4 class="text-sm font-bold text-gray-700 mb-2">تفکیک امتیازات</h4> <!-- [کوچک‌سازی] base به sm -->
                            <div class="w-full max-w-xs mx-auto h-48">
                                <canvas id="ratingChart"></canvas>
                            </div>
                            <!-- نمودار خطی -->
                            <h4 class="text-sm font-bold text-gray-700 mt-6 mb-2">حجم تیکت (۷ روز گذشته)</h4> <!-- [کوچک‌سازی] base به sm -->
                            <div class="w-full h-48">
                                <canvas id="volumeChart"></canvas>
                            </div>
                        </div>
                    </div>

                    <button onclick="navigateTo('MainMenu', 'مدیریت متون')" class="w-full bg-white text-gray-900 py-4 mt-3 rounded-2xl shadow-lg hover:shadow-xl transition duration-300 font-bold flex items-center justify-center text-sm btn-press fade-in-up" style="animation-delay: 400ms;"> <!-- [کوچک‌سازی] base به sm -->
                        <i data-lucide="settings" class="h-6 w-6 ml-2 text-indigo-600"></i>
                        مدیریت متون و تنظیمات
                    </button>
                </div>
            `;

            // [جدید] رندر کردن نمودارها پس از رندر HTML
            // [اصلاح شد] تاخیر کوتاه برای اطمینان از رندر شدن canvas
            setTimeout(() => {
                initRatingChart();
                initVolumeChart();
            }, 100);
        }

        // [جدید] تابع رندر لیست تیکت‌ها
        function renderTicketsList() {
            backButton.classList.add('hidden'); // صفحه اصلی تب تیکت‌ها دکمه بازگشت ندارد
            headerTitle.textContent = 'لیست تیکت‌ها';
            // [جدید] تغییر پس‌زمینه محتوا
            content.className = 'p-4 space-y-4'; // بازگرداندن به حالت عادی

            if (successMessage) {
                showMessage(successMessage);
                successMessage = null;
            }

            // [اصلاح شد] اکنون appTickets یک آرایه است و این کد به درستی کار می‌کند
            const filteredTickets = appTickets.filter(t => t.status === currentTicketListFilter);
            const openTicketsCount = appTickets.filter(t => t.status === 'open').length;
            const closedTicketsCount = appTickets.filter(t => t.status === 'closed').length;


            content.innerHTML = `
                <div class="fade-in-up">
                    <!-- [جدید] تب‌های فیلتر -->
                    <div class="flex items-center justify-center space-x-2 space-x-reverse bg-gray-200 p-1 rounded-full mb-5">
                        <button onclick="filterTickets('open')" class="ticket-tab w-full text-center px-4 py-2 rounded-full font-semibold transition-all duration-300 ${currentTicketListFilter === 'open' ? 'active' : 'text-gray-700'}">
                            باز (${openTicketsCount})
                        </button>
                        <button onclick="filterTickets('closed')" class="ticket-tab w-full text-center px-4 py-2 rounded-full font-semibold transition-all duration-300 ${currentTicketListFilter === 'closed' ? 'active' : 'text-gray-700'}">
                            بسته (${closedTicketsCount})
                        </button>
                    </div>

                    <!-- [جدید] لیست تیکت‌ها -->
                    <div class="space-y-4">
                        ${filteredTickets.length > 0 ? filteredTickets.map((ticket, index) => `
                            <div class="bg-white rounded-2xl shadow-lg p-4 cursor-pointer transition duration-200 hover:shadow-xl btn-press fade-in-up" style="animation-delay: ${50 + index * 50}ms;" onclick="navigateTo('TicketView_${ticket.id}', '${ticket.subject}')">
                                <div class="flex items-center justify-between mb-2">
                                    <span class="font-bold text-gray-800 text-sm truncate">${ticket.subject || 'بدون موضوع'}</span> <!-- [کوچک‌سازی] base به sm -->
                                    <!-- [اصلاح شد] نمایش زمان ایجاد با فرمت بهتر -->
                                    <span class="text-xs font-semibold text-gray-500">${new Date(ticket.created_at).toLocaleTimeString('fa-IR', { hour: '2-digit', minute: '2-digit' }) || ''}</span>
                                </div>
                                <div class="flex items-center justify-between text-xs"> <!-- [کوچک‌سازی] sm به xs -->
                                     <!-- [اصلاح شد] نمایش user_name اگر وجود دارد -->
                                    <span class="text-gray-600">${ticket.user_name || 'کاربر ناشناس'}</span>
                                    <!-- [اصلاح شد] استفاده از departmentMap تعریف شده در همین فایل -->
                                     <span class="text-xs font-semibold ${
                                        ticket.department === 'technical' ? 'bg-blue-100 text-blue-700' :
                                        ticket.department === 'sales' ? 'bg-green-100 text-green-700' :
                                        ticket.department === 'marketing' ? 'bg-purple-100 text-purple-700' :
                                        ticket.department === 'ideas' ? 'bg-yellow-100 text-yellow-700' :
                                        'bg-gray-100 text-gray-700' // Default for general or unknown
                                    } px-2 py-0.5 rounded-full">${
                                        departmentMap[ticket.department] || ticket.department || 'عمومی' // استفاده از departmentMap
                                    }</span>
                                </div>
                            </div>
                        `).join('') : `
                            <div class="text-center text-gray-500 pt-10 fade-in-up">
                                <i data-lucide="inbox" class="h-12 w-12 mx-auto text-gray-400"></i>
                                <p class="mt-2 font-semibold">هیچ تیکت ${currentTicketListFilter === 'open' ? 'بازی' : 'بسته‌ای'} یافت نشد.</p>
                            </div>
                        `}
                    </div>
                </div>
            `;
        }

        // [جدید] تابع برای تغییر فیلتر تیکت‌ها
        function filterTickets(status) {
            currentTicketListFilter = status;
            render(); // رندر مجدد صفحه تیکت‌ها
        }

        // [اصلاح شد] تابع رندر صفحه مشاهده تیکت
        function renderTicketView(state) {
            backButton.classList.remove('hidden'); // نمایش دکمه بازگشت
            const ticketId = state.replace('TicketView_', '');
            // [اصلاح شد] اکنون appTickets یک آرایه است و .find() کار می‌کند
            const ticket = appTickets.find(t => t.id === ticketId);

            if (!ticket) {
                content.innerHTML = `<p class="text-red-600 p-4 font-bold">خطا: تیکت یافت نشد.</p>`;
                return;
            }

            headerTitle.textContent = ticket.subject;
            // [جدید] تغییر پس‌زمینه محتوا
            content.className = 'p-4 chat-container-bg';

             // [اصلاح شد] استفاده از لودر واقعی
             content.innerHTML = `
                 <div class="fade-in-up space-y-3"> 
                     <!-- [اصلاح شد] پیام سیستمی به سبک تلگرام -->
                     <div class="flex justify-center my-3">
                         <div class="text-xs text-gray-500 font-medium text-center p-2">
                            کاربر <strong>${ticket.user_name || 'ناشناس'}</strong> تیکت را در دپارتمان <strong>${departmentMap[ticket.department] || 'عمومی'}</strong> باز کرد
                         </div>
                     </div>
                     <div id="messages-container" class="space-y-3 pb-4"> 
                         <div class="text-center text-gray-500 pt-10">
                            <i data-lucide="loader-circle" class="animate-spin h-8 w-8 mx-auto text-indigo-600"></i>
                            <p>در حال بارگذاری پیام‌ها...</p>
                         </div>
                     </div>
                 </div>
             `;
            
             fetchMessagesForTicket(ticketId, ticket); // [اصلاح شد] ارسال کل آبجکت تیکت
             lucide.createIcons();
        }

       // [اصلاح شد] تابع واکشی و رندر پیام‌ها
       async function fetchMessagesForTicket(ticketId, ticket) { 
            const messagesContainer = document.getElementById('messages-container');
            if (!messagesContainer || currentState !== `TicketView_${ticketId}`) {
                return;
            }

            // [جدید] نمایش مجدد لودر قبل از هر بار واکشی
            messagesContainer.innerHTML = `
                <div class="text-center text-gray-500 pt-5">
                    <i data-lucide="loader-circle" class="animate-spin h-8 w-8 mx-auto text-indigo-600"></i>
                    <p>در حال بارگذاری پیام‌ها...</p>
                 </div>`;
            lucide.createIcons(); // رندر آیکون لودر

            const currentStoreHandle = STORE_HANDLE || MOCK_STORE_HANDLE;

            // --- حالت آزمایشی ---
            if (currentStoreHandle === MOCK_STORE_HANDLE) {
                console.log("Mock mode: Loading messages from mock ticket object for ticket:", ticketId);
                const currentTicket = ticket || appTickets.find(t => t.id === ticketId);
                
                await new Promise(resolve => setTimeout(resolve, 500)); // شبیه‌سازی تاخیر

                const messages = currentTicket?.messages?.sort((a, b) => new Date(a.created_at) - new Date(b.created_at)) || [];
                renderMessages(messages, messagesContainer, currentTicket); 
                lucide.createIcons(); 
                 setTimeout(() => {
                    if (messagesContainer) { 
                      console.log("Scrolling mock messages to bottom");
                      window.scrollTo(0, document.body.scrollHeight); 
                    }
                 }, 50); 
                return;
            }
            // --- پایان حالت آزمایشی ---

            const url = `${WORKER_API_BASE_URL}/api/${currentStoreHandle}/messages?ticket_id=${ticketId}`;
            try {
                console.log(`Fetching messages from: ${url}`); // Log fetch attempt
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to fetch messages (${response.status})`);
                const result = await response.json();
                 console.log("Messages API response:", result); // Log API response
                if (!result.success) throw new Error(result.error || 'Worker messages returned error.');

                // تبدیل آبجکت پیام‌ها به آرایه و مرتب‌سازی بر اساس زمان
                const messagesObject = result.data || {};
                const messagesArray = Object.values(messagesObject).sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                 console.log("Sorted messages array:", messagesArray); // Log sorted array

                // رندر کردن پیام‌ها در کانتینر
                renderMessages(messagesArray, messagesContainer, ticket); // [اصلاح شد] ارسال تیکت

            } catch (error) {
                console.error("Error fetching messages:", error.message);
                showMessage(`❌ خطا در واکشی پیام‌ها: ${error.message}.`, 'error');
                 if (messagesContainer) {
                    // [اصلاح شد] نمایش پیام خطا در کانتینر
                    messagesContainer.innerHTML = `<p class="text-red-600 p-4 font-bold text-center">خطا در بارگذاری پیام‌ها.</p>`;
                 }
            } finally {
                 // اطمینان از رندر شدن آیکون‌ها حتی در صورت خطا
                 lucide.createIcons();
                 // اسکرول به پایین بعد از رندر یا خطا
                 setTimeout(() => {
                    if (messagesContainer) {
                        console.log("Scrolling messages container to bottom after fetch/render"); // Log scroll attempt
                        window.scrollTo(0, document.body.scrollHeight);
                    }
                 }, 50); // Small delay for DOM update
            }
        }

        // [جدید] تابع کمکی برای رندر کردن آرایه پیام‌ها در DOM
        function renderMessages(messagesArray, containerElement, ticket) {
            if (!containerElement || !ticket) {
                 console.error("RenderMessages failed: container or ticket missing");
                 return;
             }

            if (messagesArray.length === 0) {
                 containerElement.innerHTML = `<p class="text-gray-500 text-center pt-5">هنوز پیامی رد و بدل نشده است.</p>`;
                 return;
             }
             
             // [جدید] تابع استخراج حروف اول نام
            const getInitials = (name) => {
                if (!name) return '؟';
                const parts = name.split(' ');
                if (parts.length === 1) return name.substring(0, 1);
                const first = parts[0] ? parts[0].substring(0, 1) : '';
                const second = parts[1] ? parts[1].substring(0, 1) : '';
                return (first + second).toUpperCase() || '؟';
            }
            const userInitials = getInitials(ticket.user_name);

             // Ensure text exists and replace newlines - Escape HTML for safety
            const sanitizeText = (text = '') => {
                 const escapedText = text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                 return escapedText.replace(/\n/g, '<br>');
            }

            containerElement.innerHTML = messagesArray.map(msg => {
                const isUser = msg.sender === 'user';
                
                const avatarHTML = isUser 
                    ? `<div class="chat-avatar">${userInitials}</div>` 
                    : '';
                
                // [اصلاح شد] آیکون دو تیک و رنگ آبی
                const metaHTML = `
                    <div class="text-xs ${isUser ? 'text-gray-500' : 'text-gray-500'} mt-1 ${isUser ? 'text-left' : 'text-right'} flex items-center ${isUser ? 'justify-start' : 'justify-end'}">
                        ${!isUser ? '<i data-lucide="check-check" class="h-3.5 w-3.5 text-blue-600 ml-1"></i>' : ''}
                        ${new Date(msg.created_at).toLocaleTimeString('fa-IR', { hour: '2-digit', minute: '2-digit' })}
                    </div>
                `;


                return `
                <!-- [اصلاح شد] چینش برای آواتار -->
                <div class="flex ${isUser ? 'justify-end' : 'justify-start'} items-end space-x-2 space-x-reverse fade-in-up" style="animation-delay: ${messagesArray.indexOf(msg) * 30}ms"> 
                    
                    <!-- [جدید] کانتینر برای حباب + متا -->
                    <div class="flex flex-col">
                        <div class="chat-bubble ${isUser ? 'incoming' : 'outgoing'} w-fit"> 
                            ${
                                // نمایش Placeholder برای تصاویر
                                msg.type === 'image_placeholder'
                                ? `<span class="italic text-gray-500">${sanitizeText(msg.text)}</span>`
                                : sanitizeText(msg.text) // نمایش متن معمولی
                             }
                        </div>
                        <!-- [جدید] متا (زمان/وضعیت) در خارج از حباب -->
                        ${metaHTML}
                    </div>

                    <!-- آواتار کاربر -->
                    ${avatarHTML}
                </div>
            `}).join('');
         }



        function renderMainMenu() {
            backButton.classList.remove('hidden');
            headerTitle.textContent = 'مدیریت متون';
            // [جدید] تغییر پس‌زمینه محتوا
            content.className = 'p-4 space-y-4'; 

            if (successMessage) {
                showMessage(successMessage);
                successMessage = null;
            }

            content.innerHTML = `
                <h2 class="text-xl font-extrabold text-gray-800 mb-2 fade-in-up">شخصی‌سازی محتوا</h2> <!-- [کوچک‌سازی] 2xl به xl -->
                <p class="text-xs text-gray-500 mb-6 fade-in-up" style="animation-delay: 50ms;">متون کلیدی مینی اپ و اعلان‌های ربات را ویرایش کنید.</p> <!-- [کوچک‌سازی] sm به xs -->

                <div class="space-y-4">
                    <div class="bg-white rounded-2xl shadow-lg p-5 cursor-pointer transition duration-200 hover:shadow-xl btn-press fade-in-up" style="animation-delay: 100ms;" onclick="navigateTo('SubMenu_MINI_APP_UI', 'متن‌های مینی‌اپ')">
                        <div class="flex items-center justify-between">
                            <span class="flex items-center font-bold text-gray-800 text-sm"> <!-- [کوچک‌سازی] base به sm -->
                                <i data-lucide="smartphone" class="h-6 w-6 ml-3 text-indigo-600"></i>
                                متن‌های مینی‌اپ
                            </span>
                            <i data-lucide="chevron-left" class="h-5 w-5 text-gray-400"></i>
                        </div>
                        <p class="text-xs text-gray-500 mt-2 pr-9">ویرایش رابط کاربری و پیام‌های داخل مینی‌اپ.</p> <!-- [کوچک‌سازی] sm به xs -->
                    </div>

                    <div class="bg-white rounded-2xl shadow-lg p-5 cursor-pointer transition duration-200 hover:shadow-xl btn-press fade-in-up" style="animation-delay: 150ms;" onclick="navigateTo('SubMenu_USER_NOTIFICATIONS', 'متن‌های اعلان ربات')">
                        <div class="flex items-center justify-between">
                            <span class="flex items-center font-bold text-gray-800 text-sm"> <!-- [کوچک‌سازی] base به sm -->
                                <i data-lucide="bell" class="h-6 w-6 ml-3 text-orange-600"></i>
                                متن‌های اعلان کاربر
                            </span>
                            <i data-lucide="chevron-left" class="h-5 w-5 text-gray-400"></i>
                        </div>
                        <p class="text-xs text-gray-500 mt-2 pr-9">ویرایش پیام‌هایی که ربات برای کاربران ارسال می‌کند.</p> <!-- [کوچک‌سازی] sm به xs -->
                    </div>
                </div>
            `;
        }
        function renderSubMenu_Texts(state) {
            backButton.classList.remove('hidden');
            const menuType = state.replace('SubMenu_', '');
            const keys = CUSTOM_TEXT_KEYS[menuType];
            const menuTitle = menuType === 'MINI_APP_UI' ? "متن‌های مینی‌اپ" : "متن‌های اعلان ربات";

            headerTitle.textContent = menuTitle;
            // [جدید] تغییر پس‌زمینه محتوا
            content.className = 'p-4 space-y-4'; 

            if (successMessage) {
                showMessage(successMessage);
                successMessage = null;
            }

            content.innerHTML = `
                <h2 class="text-xl font-extrabold text-gray-800 mb-2 fade-in-up">${menuTitle}</h2> <!-- [کوچک‌سازی] 2xl به xl -->
                <p class="text-xs text-gray-500 mb-6 fade-in-up" style="animation-delay: 50ms;">متن مورد نظر برای ویرایش را انتخاب کنید:</p> <!-- [کوچک‌سازی] sm به xs -->

                <div class="space-y-4">
                    ${Object.entries(keys).map(([key, data], index) => {
                        const menuIcon = data.icon || 'file-text';
                        const iconColor = menuType === 'MINI_APP_UI' ? 'text-indigo-500' : 'text-orange-500';

                        let additionalInfo = '';
                        if (data.isBoolean) {
                            const currentValue = (appTexts[key] === "true" || typeof appTexts[key] === 'undefined'); // Default to true if undefined
                            additionalInfo = currentValue
                                ? `<span class="text-xs font-semibold bg-green-100 text-green-700 px-2 py-0.5 rounded-full">فعال</span>`
                                : `<span class="text-xs font-semibold bg-gray-100 text-gray-600 px-2 py-0.5 rounded-full">غیرفعال</span>`;
                        }

                        return `
                            <div class="bg-white rounded-2xl shadow-lg p-5 cursor-pointer transition duration-200 hover:shadow-xl btn-press fade-in-up" style="animation-delay: ${100 + index * 50}ms;" onclick="navigateTo('EditScreen_${key}', 'ویرایش: ${data.name}')">
                                <div class="flex items-center justify-between">
                                    <span class="flex items-center font-bold text-gray-800 text-sm"> <!-- [کوچک‌سازی] base به sm -->
                                        <i data-lucide="${menuIcon}" class="h-6 w-6 ml-3 ${iconColor}"></i>
                                        ${data.name}
                                    </span>
                                    <div class="flex items-center">
                                        ${additionalInfo}
                                        <i data-lucide="chevron-left" class="h-5 w-5 text-gray-400 ml-2"></i>
                                    </div>
                                </div>
                                <p class="text-xs text-gray-500 mt-2 pr-9">${data.desc}</p> <!-- [کوچک‌سازی] sm به xs -->
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }
        function renderEditScreen(state) {
            backButton.classList.remove('hidden');
            currentEditKey = state.replace('EditScreen_', '');
            const keyData = getFullKeyData(currentEditKey);

            if (!keyData) {
                content.innerHTML = `<p class="text-red-600 p-4 font-bold">خطا: کلید متنی نامعتبر است.</p>`;
                return;
            }

            headerTitle.textContent = `ویرایش: ${keyData.name}`;
            // [جدید] تغییر پس‌زمینه محتوا
            content.className = 'p-4 space-y-4'; 

            const isNotification = keyData.type === 'USER_NOTIFICATIONS';
            const isUrlField = keyData.isUrl;
            const isBooleanField = keyData.isBoolean;

            // Default text handling improved: Use empty string if no default specified
            const currentText = (appTexts[currentEditKey] ?? keyData.defaultText ?? "").replace(/\\n/g, '\n');

            let markdownGuideHTML = '';
            let inputElement;

            if (isNotification) {
                markdownGuideHTML = `
                    <div class="bg-blue-50 border border-blue-200 p-4 mb-5 rounded-2xl text-xs text-gray-700 shadow-md fade-in-up" style="animation-delay: 50ms;"> <!-- [کوچک‌سازی] sm به xs -->
                        <p class="font-bold text-blue-700 flex items-center mb-2"><i data-lucide="code" class="h-5 w-5 ml-2"></i> راهنمای Markdown و متغیرها</p>
                        <div class="bg-white border rounded-lg overflow-hidden mt-3">
                            <table class="w-full text-right text-xs">
                                <thead class="bg-gray-100 font-semibold text-gray-600"><tr><th class="p-2 border-b">سینتکس</th><th class="p-2 border-b">توضیح</th><th class="p-2 border-b">نمونه</th></tr></thead>
                                <tbody>
                                    <tr class="hover:bg-gray-50"><td class="p-2 border-b font-mono">**متن**</td><td class="p-2 border-b">بولد</td><td class="p-2 border-b font-bold">متن</td></tr>
                                    <tr class="hover:bg-gray-50"><td class="p-2 border-b font-mono">*متن*</td><td class="p-2 border-b">کج</td><td class="p-2 border-b italic">متن</td></tr>
                                    <tr class="hover:bg-gray-50"><td class="p-2 border-b font-mono">\`کد\`</td><td class="p-2 border-b">کد</td><td class="p-2 border-b font-mono text-sm bg-gray-100 rounded">کد</td></tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="font-bold text-blue-700 mt-4 mb-1 flex items-center"><i data-lucide="variable" class="h-5 w-5 ml-2"></i> متغیرهای پویا</p>
                        <ul class="list-disc pr-5 space-y-1 font-mono text-xs">
                            <li><code>{Subject}</code>: موضوع تیکت</li>
                            <li><code>{Department}</code>: نام دپارتمان</li>
                        </ul>
                    </div>
                `;
            } else {
                 const description = keyData.desc || 'توضیحات خاصی برای این متن موجود نیست.';
                 markdownGuideHTML = `
                       <div class="bg-yellow-50 border border-yellow-200 p-4 mb-5 rounded-2xl text-xs text-gray-700 flex items-start shadow-md fade-in-up" style="animation-delay: 50ms;"> <!-- [کوچک‌سازی] sm به xs -->
                            <i data-lucide="alert-triangle" class="h-5 w-5 ml-2 text-yellow-700 flex-shrink-0 mt-0.5"></i>
                            <div>
                                 <span class="font-bold text-yellow-700 ml-1">راهنما:</span>
                                 <span>${description}</span>
                            </div>
                       </div>
                     `;
            }

            if (isUrlField) {
                inputElement = `
                    <input id="edit-area" type="url" value="${currentText.replace(/\n/g, '')}" class="w-full p-4 border border-gray-300 rounded-2xl shadow-md focus:border-indigo-500 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 transition duration-150 text-gray-800 text-xs" placeholder="مثلاً: https://yourdomain.com/faq"> <!-- [کوچک‌سازی] sm به xs -->
                `;
            } else if (isBooleanField) {
                inputElement = `
                    <select id="edit-area" class="w-full p-4 border border-gray-300 rounded-2xl shadow-md focus:border-indigo-500 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 transition duration-150 text-gray-800 text-xs bg-white"> <!-- [کوچک‌سازی] sm به xs -->
                        <option value="true" ${currentValue === "true" ? 'selected' : ''}>فعال (نمایش داده شود)</option>
                        <option value="false" ${currentValue === "false" ? 'selected' : ''}>غیرفعال (مخفی شود)</option>
                    </select>
                `;
            } else {
                inputElement = `
                    <textarea id="edit-area" rows="4" class="auto-resize-textarea w-full p-4 border border-gray-300 rounded-2xl shadow-md focus:border-indigo-500 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 transition duration-150 text-gray-800 text-xs" placeholder="متن جدید خود را اینجا وارد کنید...">${currentText}</textarea> <!-- [کوچک‌سازی] sm به xs -->
                `;
            }

            content.innerHTML = `
                <h2 class="text-xl font-extrabold text-gray-800 mb-2 fade-in-up">${keyData.name}</h2> <!-- [کوچک‌سازی] 2xl به xl -->

                ${markdownGuideHTML}

                <!-- [جدید] انیمیشن به ناحیه ویرایش اضافه شد -->
                <div class="fade-in-up" style="animation-delay: 100ms;">
                    ${inputElement}
                </div>

                <div class="flex justify-end space-x-3 mt-6 fade-in-up" style="animation-delay: 150ms;" dir="ltr">
                    <button onclick="handleBack()" class="px-6 py-3 bg-white text-gray-800 rounded-2xl hover:bg-gray-50 transition duration-150 font-semibold shadow-lg btn-press">
                        <i data-lucide="x" class="h-5 w-5 inline ml-1"></i> لغو
                    </button>
                    <button id="save-button" onclick="handleSave()" class="px-6 py-3 bg-indigo-600 text-white rounded-2xl hover:bg-indigo-700 transition duration-150 font-semibold shadow-lg shadow-indigo-400/50 btn-press">
                        <i data-lucide="save" class="h-5 w-5 inline ml-1"></i> ذخیره تغییرات
                    </button>
                </div>
            `;

            const editArea = document.getElementById('edit-area');
            if (editArea && !isUrlField && !isBooleanField) {
                autoResize(editArea);
                editArea.addEventListener('input', () => autoResize(editArea));
            }
        }

        // --- [جدید] توابع رندر نمودار ---

        function initRatingChart() {
            const ctx = document.getElementById('ratingChart');
            // [اصلاح شد] بررسی می‌کند که آیا بوم و داده‌ها قبل از رندر وجود دارند یا خیر
            if (!ctx || !chartData || !chartData.ratings) {
                console.warn('Rating chart canvas or data not ready.');
                return;
            }

            // از بین بردن نمودار قبلی اگر وجود داشت
            if (ratingChartInstance) {
                ratingChartInstance.destroy();
            }

            ratingChartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: chartData.ratings.labels,
                    datasets: [{
                        label: 'تعداد امتیاز',
                        data: chartData.ratings.data,
                        backgroundColor: [
                            '#16a34a', // 5 ستاره (سبز)
                            '#ca8a04', // 4 ستاره (زرد)
                            '#ea580c', // 3 ستاره (نارنجی)
                            '#dc2626', // 2 ستاره (قرمز)
                            '#7f1d1d'  // 1 ستاره (قرمز تیره)
                        ],
                        borderColor: '#ffffff',
                        borderWidth: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                fontFamily: 'Vazirmatn',
                                boxWidth: 12,
                                padding: 15
                            }
                        }
                    }
                }
            });
        }

        function initVolumeChart() {
            const ctx = document.getElementById('volumeChart');
            // [اصلاح شد] بررسی می‌کند که آیا بوم و داده‌ها قبل از رندر وجود دارند یا خیر
            if (!ctx || !chartData || !chartData.volume) {
                 console.warn('Volume chart canvas or data not ready.');
                return;
            }

            if (volumeChartInstance) {
                volumeChartInstance.destroy();
            }

            volumeChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.volume.labels,
                    datasets: [{
                        label: 'تیکت‌های ورودی',
                        data: chartData.volume.data,
                        fill: true,
                        backgroundColor: 'rgba(79, 70, 229, 0.1)', // آبی ملایم
                        borderColor: '#4f46e5', // آبی
                        tension: 0.3, // منحنی نرم
                        pointBackgroundColor: '#4f46e5',
                        pointBorderWidth: 2,
                        pointRadius: 4,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false // مخفی کردن لجند
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: '#f0f2f5' // خطوط گرید کمرنگ
                            },
                            ticks: {
                                stepSize: 1, // گام‌های ۱ واحدی
                                fontFamily: 'Vazirmatn'
                            }
                        },
                        x: {
                            grid: {
                                display: false // حذف گرید عمودی
                            },
                            ticks: {
                                fontFamily: 'Vazirmatn'
                            }
                        }
                    }
                }
            });
        }


        // --- [به‌روزرسانی] تابع اصلی رندر ---

        function render() {
            content.classList.add('transition-all', 'duration-200', 'opacity-0');

            // [اصلاح شد] اطمینان از پاک شدن نمودارهای قبلی
            if (currentState !== 'Dashboard') {
                 if (ratingChartInstance) {
                     ratingChartInstance.destroy();
                     ratingChartInstance = null;
                 }
                if (volumeChartInstance) {
                    volumeChartInstance.destroy();
                    volumeChartInstance = null;
                }
            }

            setTimeout(() => {

                if (currentState === 'Dashboard-Loading') {
                    renderDashboardSkeleton();
                } else if (currentState === 'Dashboard') {
                    renderDashboard();
                } else if (currentState === 'TicketsList') { // [جدید]
                    renderTicketsList();
                } else if (currentState.startsWith('TicketView_')) { // [جدید]
                    renderTicketView(currentState);
                } else if (currentState === 'MainMenu') {
                    renderMainMenu();
                } else if (currentState.startsWith('SubMenu_')) {
                    renderSubMenu_Texts(currentState);
                } else if (currentState.startsWith('EditScreen_')) {
                    renderEditScreen(currentState);
                } else {
                    renderDashboard(); // Fallback
                }

                backButton.classList[history.length > 0 ? 'remove' : 'add']('hidden');
                updateFooterNav(currentState);

                content.classList.remove('opacity-0');

                // [اصلاح شد] فراخوانی createIcons در همه رندرها به جز لودینگ
                if (currentState !== 'Dashboard-Loading') {
                    lucide.createIcons();
                }

            }, 50);
        }

        // --- [جدید] تابع امن برای تنظیم انتخابگر ایموجی ---
        async function setupEmojiPicker() {
            try {
                // 1. منتظر بمانید تا کامپوننت 'emoji-picker' به طور کامل تعریف و آماده شود
                await customElements.whenDefined('emoji-picker');
                
                // 2. حالا که کامپوننت آماده است، المان‌ها را پیدا کنید
                const emojiPicker = document.getElementById('emoji-picker');
                const emojiBtn = document.getElementById('emoji-btn');
                const cannedReplyBtn = document.getElementById('canned-reply-btn');

                if (!emojiPicker || !emojiBtn || !cannedReplyBtn) {
                    console.error('Emoji picker elements not found after component definition.');
                    return;
                }

                // 3. حالا تنظیم i18n (ترجمه‌ها) امن است
                emojiPicker.i18n = {
                    "search": "جستجو",
                    "categories": {
                        "activity": "فعالیت",
                        "animals-nature": "حیوانات و طبیعت",
                        "component": "کامپوننت",
                        "flags": "پرچم‌ها",
                        "food-drink": "غذا و نوشیدنی",
                        "objects": "اشیاء",
                        "people-body": "مردم و بدن",
                        "smileys-emotion": "شکلک‌ها و احساسات",
                        "symbols": "نمادها",
                        "travel-places": "سفر و مکان‌ها"
                    },
                    "skintones": {
                        "choose": "انتخاب رنگ پوست پیش‌فرض",
                        "1": "پیش‌فرض",
                        "2": "روشن",
                        "3": "متوسط-روشن",
                        "4": "متوسط",
                        "5": "متوسط-تیره",
                        "6": "تیره"
                    }
                };

                // 4. حالا اضافه کردن event listener ها امن است
                
                // باز/بسته کردن انتخابگر ایموجی
                emojiBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    emojiPicker.classList.toggle('visible');
                });

                // درج ایموجی در متن
                emojiPicker.addEventListener('emoji-click', event => {
                    insertTextAtCursor(replyTextarea, event.detail.unicode);
                });

                // دکمه پاسخ‌های آماده (در حال حاضر فقط پیام می‌دهد)
                cannedReplyBtn.addEventListener('click', () => {
                    showMessage('💡 (آزمایشی) بخش پاسخ‌های آماده در دست ساخت است.', 'info');
                });

            } catch (error) {
                console.error("Failed to setup emoji picker:", error);
                showMessage('❌ خطا در بارگذاری انتخابگر ایموجی.', 'error');
            }
        }


        // [اصلاح شد] رویدادهای اصلی
        backButton.addEventListener('click', handleBack);
        
        // [اصلاح شد] رویدادهای مربوط به کادر پاسخ که به ایموجی‌ پیکر وابسته نیستند
        
        // بستن انتخابگر ایموجی با کلیک در جای دیگر (این listener باید عمومی باشد)
        document.addEventListener('click', (e) => {
            const emojiPicker = document.getElementById('emoji-picker');
            const emojiBtn = document.getElementById('emoji-btn');
            // اطمینان از اینکه المان‌ها وجود دارند قبل از بررسی contains
            if (emojiPicker && emojiBtn && !emojiPicker.contains(e.target) && !emojiBtn.contains(e.target)) {
                emojiPicker.classList.remove('visible');
            }
        });

        // تغییر اندازه خودکار فیلد پاسخ
        replyTextarea.addEventListener('input', () => autoResize(replyTextarea));

        // ارسال پیام با دکمه Enter (و Shift+Enter برای خط جدید)
        replyTextarea.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // جلوگیری از ایجاد خط جدید
                if (replyTextarea.value.trim() !== '' && currentTicketId) {
                    sendAdminReplyToWorker(currentTicketId, replyTextarea.value.trim());
                }
            }
        });

        // ارسال پیام با کلیک روی دکمه ارسال
        sendReplyBtn.addEventListener('click', () => {
            if (replyTextarea.value.trim() !== '' && currentTicketId) {
                sendAdminReplyToWorker(currentTicketId, replyTextarea.value.trim());
            }
        });


        // شروع اپلیکیشن
        fetchInitialData();

        // آیکون‌های اولیه نوار پایین را رندر می‌کند
        lucide.createIcons();

        // [جدید] فراخوانی تابع امن برای تنظیم ایموجی
        setupEmojiPicker();
    </script>
</body>
</html>

